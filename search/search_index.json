{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction jsii allows code in any language to naturally interact with JavaScript classes. It is the technology that enables the AWS Cloud Development Kit to deliver polyglot libraries from a single codebase! A class library written in TypeScript can be used in projects authored in TypeScript or Javascript (as usual), but also in C# (and other languages from the .NET family), Go , Java , Python , ... More languages will be added in the future! Warning Due to JSON marshaling costs and the absence of a distributed garbage collector feature, jsii modules are best suited for development and build tools, as opposed to performance-sensitive or resource-constrained applications. See Runtime Architecture for more information. An example is worth a thousand words Consider the following TypeScript class: /** * A simple greeter, hello world style. */ export class Greeter { /** * Greets the designated person. * * @param name the person to greet. * * @returns a greeting. */ public greet ( name : string ) { return `Hello, ${ name } !` ; } } By compiling our source module using jsii , we can now package it as modules in one of the supported target languages. Each target module has the exact same API as the source. This allows users of that target language to use Greeter like any other native type: C# var greeter = new Greeter (); greeter . Greet ( \"World\" ); // => Hello, World! Go greeter := NewGreeter () greeter . Greet ( \"World\" ) // => Hello, World! Java final Greeter greeter = new Greeter (); greeter . greet ( \"World\" ); // => Hello, World! JavaScript const greeter = new Greeter (); greeter . greet ( \"World\" ); // => Hello, World! Python greeter = Greeter () greeter . greet ( \"World\" ) # => Hello, World! How to use this website The documentation in this website is separated in different topics, which can be navigated using links in the site's header bar: The Welcome section provides a high level overview of jsii . The User Guides section includes the following: The Library Author Guide is intended for developers who are looking to author libraries using jsii to enable polyglot support for their work. The Library Consumer Guide is intended for developers who are consuming libraries generated by jsii in the various supported target languages. The Language Implementation is intended for developers who are looking to add support for a new target language in jsii . The Specification provides detailed information on the internal components of jsii . The Architecture Decision Records contains the log of all architectural decisions made while developing the jsii project. How to contribute The jsii project welcomes all kind of contributions. You can refer to the Contribution Guide on GitHub to get more information about how to contribute to the project in general. Tip You can submit pull requests for documentation updates without leaving the comfort of your web browser! All pages of this website have a icon on the top right of each page that links to a GitHub web editor for the source of the page in question.","title":"Introduction"},{"location":"#introduction","text":"jsii allows code in any language to naturally interact with JavaScript classes. It is the technology that enables the AWS Cloud Development Kit to deliver polyglot libraries from a single codebase! A class library written in TypeScript can be used in projects authored in TypeScript or Javascript (as usual), but also in C# (and other languages from the .NET family), Go , Java , Python , ... More languages will be added in the future! Warning Due to JSON marshaling costs and the absence of a distributed garbage collector feature, jsii modules are best suited for development and build tools, as opposed to performance-sensitive or resource-constrained applications. See Runtime Architecture for more information.","title":"Introduction"},{"location":"#an-example-is-worth-a-thousand-words","text":"Consider the following TypeScript class: /** * A simple greeter, hello world style. */ export class Greeter { /** * Greets the designated person. * * @param name the person to greet. * * @returns a greeting. */ public greet ( name : string ) { return `Hello, ${ name } !` ; } } By compiling our source module using jsii , we can now package it as modules in one of the supported target languages. Each target module has the exact same API as the source. This allows users of that target language to use Greeter like any other native type: C# var greeter = new Greeter (); greeter . Greet ( \"World\" ); // => Hello, World! Go greeter := NewGreeter () greeter . Greet ( \"World\" ) // => Hello, World! Java final Greeter greeter = new Greeter (); greeter . greet ( \"World\" ); // => Hello, World! JavaScript const greeter = new Greeter (); greeter . greet ( \"World\" ); // => Hello, World! Python greeter = Greeter () greeter . greet ( \"World\" ) # => Hello, World!","title":"An example is worth a thousand words"},{"location":"#how-to-use-this-website","text":"The documentation in this website is separated in different topics, which can be navigated using links in the site's header bar: The Welcome section provides a high level overview of jsii . The User Guides section includes the following: The Library Author Guide is intended for developers who are looking to author libraries using jsii to enable polyglot support for their work. The Library Consumer Guide is intended for developers who are consuming libraries generated by jsii in the various supported target languages. The Language Implementation is intended for developers who are looking to add support for a new target language in jsii . The Specification provides detailed information on the internal components of jsii . The Architecture Decision Records contains the log of all architectural decisions made while developing the jsii project.","title":"How to use this website"},{"location":"#how-to-contribute","text":"The jsii project welcomes all kind of contributions. You can refer to the Contribution Guide on GitHub to get more information about how to contribute to the project in general. Tip You can submit pull requests for documentation updates without leaving the comfort of your web browser! All pages of this website have a icon on the top right of each page that links to a GitHub web editor for the source of the page in question.","title":"How to contribute"},{"location":"decisions/_README/","text":"Format So you want to add a new Architecture Decision Record to this section. This document highlights how to proceed in order to achieve a consistent look and feel, and that we capture sufficient information. Create a new document Each ADR document should be named using the following format: YYYY-MM-DD-short-name.md . This allows ensuring the documents are rendered in the correct order on the website. If is recommended to prefix the file name with the date at which the decision has been made, in ISO-8601 format. Template The following template is to be used: https://github.com/joelparkerhenderson/architecture_decision_record/blob/master/adr_template_madr.md","title":"Format"},{"location":"decisions/_README/#format","text":"So you want to add a new Architecture Decision Record to this section. This document highlights how to proceed in order to achieve a consistent look and feel, and that we capture sufficient information.","title":"Format"},{"location":"decisions/_README/#create-a-new-document","text":"Each ADR document should be named using the following format: YYYY-MM-DD-short-name.md . This allows ensuring the documents are rendered in the correct order on the website. If is recommended to prefix the file name with the date at which the decision has been made, in ISO-8601 format.","title":"Create a new document"},{"location":"decisions/_README/#template","text":"The following template is to be used: https://github.com/joelparkerhenderson/architecture_decision_record/blob/master/adr_template_madr.md","title":"Template"},{"location":"decisions/introduction/","text":"Introduction This section of the jsii reference is a log of all Architectural Decisions taken during the development of the jsii project. The Records are presented in reverse-chronological order (most recent decisions are listed first).","title":"Introduction"},{"location":"decisions/introduction/#introduction","text":"This section of the jsii reference is a log of all Architectural Decisions taken during the development of the jsii project. The Records are presented in reverse-chronological order (most recent decisions are listed first).","title":"Introduction"},{"location":"overview/features/","text":"Features TypeScript Support The jsii compiler leverages the original TypeScript compiler API to compile TypeScript source files and produce JavaScript output and TypeScript declaration files , while also extracting the compiled module's API signatures in a jsii assembly file . To determine the version of TypeScript that is in use by the installed release of jsii , simply look at the jsii --version output: # jsii --version 1.15.0 (build 585166b), typescript 3.9.7 You can then refer to the TypeScript documentation to determine which language features are available in that specific TypeScript release. Warning The jsii compiler imposes some restrictions on what TypeScript features can be used to declare the APIs exported by a jsii module , in order to ensure those APIs can be consistently represented in other languages. For more information, refer to the TypeScript Restrictions page . Target Languages The following target languages are currently offered by jsii-pacmak , or are currently being developed: Language Status C# Generally Available Go Generally Available Java Generally Available JavaScript Generally Available Kotlin Development Python Generally Available TypeScript Generally Available Status Definitions Generally Available languages are fully supported. The generated APIs will not change in breaking ways across minor and patch releases. Developer Preview languages are experimental. The generated APIs may change in breaking ways across minor releases. Development languages are not yet ready for consumption. They are actively developed and may still lack certain essential features.","title":"Features"},{"location":"overview/features/#features","text":"","title":"Features"},{"location":"overview/features/#typescript-support","text":"The jsii compiler leverages the original TypeScript compiler API to compile TypeScript source files and produce JavaScript output and TypeScript declaration files , while also extracting the compiled module's API signatures in a jsii assembly file . To determine the version of TypeScript that is in use by the installed release of jsii , simply look at the jsii --version output: # jsii --version 1.15.0 (build 585166b), typescript 3.9.7 You can then refer to the TypeScript documentation to determine which language features are available in that specific TypeScript release. Warning The jsii compiler imposes some restrictions on what TypeScript features can be used to declare the APIs exported by a jsii module , in order to ensure those APIs can be consistently represented in other languages. For more information, refer to the TypeScript Restrictions page .","title":"TypeScript Support"},{"location":"overview/features/#target-languages","text":"The following target languages are currently offered by jsii-pacmak , or are currently being developed: Language Status C# Generally Available Go Generally Available Java Generally Available JavaScript Generally Available Kotlin Development Python Generally Available TypeScript Generally Available Status Definitions Generally Available languages are fully supported. The generated APIs will not change in breaking ways across minor and patch releases. Developer Preview languages are experimental. The generated APIs may change in breaking ways across minor releases. Development languages are not yet ready for consumption. They are actively developed and may still lack certain essential features.","title":"Target Languages"},{"location":"overview/runtime-architecture/","text":"Runtime Architecture Generated Libraries When using jsii-pacmak to generate libraries in different programming languages, the Javascript code is bundled within the generated library, so that it can be used at runtime. This is the reason why a node runtime needs to be available in order to execute code that depends on jsii libraries. The generated libraries have a dependency on a Runtime client library for the language, which contains the necessary logic to start a child node process with the jsii-runtime . The jsii-runtime manages JSON-based inter-process communication over its STDIN , STDOUT and STDERR , and manages a @jsii/kernel instance that acts as a container for the Javascript code that backs the jsii libraries. Architecture Overview A representation of the execution environment of an application using jsii libraries from a different language follows: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Host Application \u2502 \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Generated Bindings\u2502 \u2502 @jsii/runtime \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Requests \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502 \u2502 \u2502 \u2502Host jsii Runtime \u2502 Responses \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Library \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502 \u2502 \u2502 \u2502 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 node \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Host Runtime \u2502 \u2502 (Child Process) \u2502 \u2502 (JVM, .NET Core, ...) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Operating System \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Communication Protocol As shown in the architecture overview diagram, the @jsii/runtime process receives requests via its STDIN stream, sends responses via its STDOUT stream, and sends console output through the STDERR stream. All those messages are sent in JSON-encoded objects. On STDIN and STDOUT , the request-response protocol is defined by the kernel api specification . On STDERR messages are encoded in the following way: { \"stderr\" : \"<base64-encoded data>\" } when the console data is to be written on the Host Application 's STDERR stream. { \"stdout\" : \"<base64-encoded data>\" } when the console data is to be written on the Host Application 's STDOUT stream. Any data that is not valid JSON, or that does not match either of the formats described above must be written as-is on the Host Application 's STDERR stream. In order to allow the hosted original JavaScript libraries to naturally interact with process.stdout , process.stderr and all other APIs that make use of those streams (such as console.log and console.error ), the @jsii/runtime process does in fact spawn a second node process to allow intercepting the console data to properly encode it. Below is a diagram describing the process arrangement that achieves this: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2502 @jsii/runtime Wrapper \u2502 \u2502 @jsii/runtime Core \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502STDIN \u2502 \u2502 X\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502STDOUT\u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 node \u2502 \u2502STDERR\u2502 node \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 JSON \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 (Child Process) \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 FD#3 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Operating System \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Missing Feature As shown on the diagram above, there is nothing connected to the Core process' FD#0 ( STDIN ). This feature will be added in the future, but currently this means jsii libraries have no way of accepting input through STDIN . The Wrapper process manages the Core process such that: Info It would be possible to use a single node process (the @jsii/runtime Core process) for any platform that supposed spawning child processes with additional open file descriptors. This is for example not possible in Java and C# , which is why this dual-process contraption was devised. In such cases, the Host Application would spawn the Core process and directly operate on the file descriptors as described below. Any requests received from the Host Application through the Wrapper 's STDIN stream is forwarded to the Core process' FD#3 . Any response written to the Core 's FD#3 stream is forwarded to the Host Application though the Wrapper 's STDOUT . Any data sent to the Core 's STDERR is base64-encoded and wrapped in a JSON object with the \"stderr\" key, then forwarded to the Host Application through the Wrapper 's STDERR Any data sent to the Core 's STDOUT is base64-encoded and wrapped in a JSON object with the \"stdout\" key, then forwarded to the Host Application through the Wrapper 's STDERR Danger As with any file descriptor besides FD#0 ( STDIN ), FD#1 ( STDOUT ) and FD#2 ( STDERR ) that was not opened by the application, JavaScript libraries loaded in the @jsii/kernel instance are not allowed to interact directly with file descriptor FD#3 . Initialization Process The initialization workflow can be described as: The host ( Java , .NET , ...) application starts on its own runtime (JVM, .NET Runtime, ...) When the host code encounters a jsii entity for the first time (creating an instance of a jsii type, loading a static constant, ...), the runtime client library creates a child node process, and loads the jsii-runtime library (specified by the JSII_RUNTIME environment variable, or the version that is bundled in the runtime client library ) The runtime client library interacts with the child node process by exchanging JSON-encoded messages through the node process' STDIN and STDOUT . It maintains a thread (or equivalent) that decodes messages from the child's STDERR stream, and forwards the decoded data to it's host process' STDERR and STDOUT as needed. The runtime client library automatically loads the Javascript modules bundled within the generated bindings (and their depedencies, bundled in other generated bindings ) into the node process when needed. Calls into the Generated bindings are encoded into JSON requests and sent to the child node process, which will execute the corresponding Javascript code, then responds back. Upon exiting, the host process closes the communication channels with the child node process, causing it to exit.","title":"Runtime Architecture"},{"location":"overview/runtime-architecture/#runtime-architecture","text":"","title":"Runtime Architecture"},{"location":"overview/runtime-architecture/#generated-libraries","text":"When using jsii-pacmak to generate libraries in different programming languages, the Javascript code is bundled within the generated library, so that it can be used at runtime. This is the reason why a node runtime needs to be available in order to execute code that depends on jsii libraries. The generated libraries have a dependency on a Runtime client library for the language, which contains the necessary logic to start a child node process with the jsii-runtime . The jsii-runtime manages JSON-based inter-process communication over its STDIN , STDOUT and STDERR , and manages a @jsii/kernel instance that acts as a container for the Javascript code that backs the jsii libraries.","title":"Generated Libraries"},{"location":"overview/runtime-architecture/#architecture-overview","text":"A representation of the execution environment of an application using jsii libraries from a different language follows: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 Host Application \u2502 \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502Generated Bindings\u2502 \u2502 @jsii/runtime \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Requests \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502 \u2502 \u2502 \u2502Host jsii Runtime \u2502 Responses \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Library \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502 \u2502 \u2502 \u2502 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 node \u2502 \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 Host Runtime \u2502 \u2502 (Child Process) \u2502 \u2502 (JVM, .NET Core, ...) \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Operating System \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518","title":"Architecture Overview"},{"location":"overview/runtime-architecture/#communication-protocol","text":"As shown in the architecture overview diagram, the @jsii/runtime process receives requests via its STDIN stream, sends responses via its STDOUT stream, and sends console output through the STDERR stream. All those messages are sent in JSON-encoded objects. On STDIN and STDOUT , the request-response protocol is defined by the kernel api specification . On STDERR messages are encoded in the following way: { \"stderr\" : \"<base64-encoded data>\" } when the console data is to be written on the Host Application 's STDERR stream. { \"stdout\" : \"<base64-encoded data>\" } when the console data is to be written on the Host Application 's STDOUT stream. Any data that is not valid JSON, or that does not match either of the formats described above must be written as-is on the Host Application 's STDERR stream. In order to allow the hosted original JavaScript libraries to naturally interact with process.stdout , process.stderr and all other APIs that make use of those streams (such as console.log and console.error ), the @jsii/runtime process does in fact spawn a second node process to allow intercepting the console data to properly encode it. Below is a diagram describing the process arrangement that achieves this: \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2510 \u2502 \u2502 \u2502 \u2502 \u2502 \u2502@jsii/kernel\u2502LibA\u2502LibB\u2502... \u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 \u2502 \u2502 @jsii/runtime Wrapper \u2502 \u2502 @jsii/runtime Core \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502STDIN \u2502 \u2502 X\u2500\u2500\u2500\u2500\u2500\u2500\u25b6STDIN \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502STDOUT\u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDOUT\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 Console \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 node \u2502 \u2502STDERR\u2502 node \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524STDERR\u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 JSON \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2524 (Child Process) \u2502 \u2502 \u25c0\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u25b6 FD#3 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2502 \u2502 \u2502 \u2502 \u2502 \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 \u2502 \u2502 \u2502 Operating System \u2502 \u2502 \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 Missing Feature As shown on the diagram above, there is nothing connected to the Core process' FD#0 ( STDIN ). This feature will be added in the future, but currently this means jsii libraries have no way of accepting input through STDIN . The Wrapper process manages the Core process such that: Info It would be possible to use a single node process (the @jsii/runtime Core process) for any platform that supposed spawning child processes with additional open file descriptors. This is for example not possible in Java and C# , which is why this dual-process contraption was devised. In such cases, the Host Application would spawn the Core process and directly operate on the file descriptors as described below. Any requests received from the Host Application through the Wrapper 's STDIN stream is forwarded to the Core process' FD#3 . Any response written to the Core 's FD#3 stream is forwarded to the Host Application though the Wrapper 's STDOUT . Any data sent to the Core 's STDERR is base64-encoded and wrapped in a JSON object with the \"stderr\" key, then forwarded to the Host Application through the Wrapper 's STDERR Any data sent to the Core 's STDOUT is base64-encoded and wrapped in a JSON object with the \"stdout\" key, then forwarded to the Host Application through the Wrapper 's STDERR Danger As with any file descriptor besides FD#0 ( STDIN ), FD#1 ( STDOUT ) and FD#2 ( STDERR ) that was not opened by the application, JavaScript libraries loaded in the @jsii/kernel instance are not allowed to interact directly with file descriptor FD#3 .","title":"Communication Protocol"},{"location":"overview/runtime-architecture/#initialization-process","text":"The initialization workflow can be described as: The host ( Java , .NET , ...) application starts on its own runtime (JVM, .NET Runtime, ...) When the host code encounters a jsii entity for the first time (creating an instance of a jsii type, loading a static constant, ...), the runtime client library creates a child node process, and loads the jsii-runtime library (specified by the JSII_RUNTIME environment variable, or the version that is bundled in the runtime client library ) The runtime client library interacts with the child node process by exchanging JSON-encoded messages through the node process' STDIN and STDOUT . It maintains a thread (or equivalent) that decodes messages from the child's STDERR stream, and forwards the decoded data to it's host process' STDERR and STDOUT as needed. The runtime client library automatically loads the Javascript modules bundled within the generated bindings (and their depedencies, bundled in other generated bindings ) into the node process when needed. Calls into the Generated bindings are encoded into JSON requests and sent to the child node process, which will execute the corresponding Javascript code, then responds back. Upon exiting, the host process closes the communication channels with the child node process, causing it to exit.","title":"Initialization Process"},{"location":"overview/toolchain/","text":"Toolchain jsii consists of multiple single-purposed programs which can be used to compose various workflows. Info We are considering creating an \"umbrella entrypoint\" to make it easier to consume. Name Stability Description jsii Stable Compiles TypeScript to jsii module jsii-pacmak Stable Creates ready-to-publish language-specific packages from jsii modules jsii-reflect Stable Strong-typed reflection library for jsii type systems jsii-diff Stable API backwards compatibility checker jsii-rosetta Experimental Transpile code snippets (in docs) from TypeScript to jsii languages jsii-config Experimental Interactive tool for generating jsii configuration jsii-release Community Publishes jsii modules to all supported package managers jsii-srcmak Community Generates relocatable source code in jsii languages from typescript jsii-docgen Community Generates markdown API documentation for jsii modules Stability Definitions Stable : Projects that comply with the Semantic Versioning specification, and will hence not change behavior or receive other breaking changes across minor and patch version bumps. Experimental : Projects that are under active development and may change behavior or receive other breaking changes across minor releases. Community : a community-maintained project, not officially supported by the jsii core team .","title":"Toolchain"},{"location":"overview/toolchain/#toolchain","text":"jsii consists of multiple single-purposed programs which can be used to compose various workflows. Info We are considering creating an \"umbrella entrypoint\" to make it easier to consume. Name Stability Description jsii Stable Compiles TypeScript to jsii module jsii-pacmak Stable Creates ready-to-publish language-specific packages from jsii modules jsii-reflect Stable Strong-typed reflection library for jsii type systems jsii-diff Stable API backwards compatibility checker jsii-rosetta Experimental Transpile code snippets (in docs) from TypeScript to jsii languages jsii-config Experimental Interactive tool for generating jsii configuration jsii-release Community Publishes jsii modules to all supported package managers jsii-srcmak Community Generates relocatable source code in jsii languages from typescript jsii-docgen Community Generates markdown API documentation for jsii modules Stability Definitions Stable : Projects that comply with the Semantic Versioning specification, and will hence not change behavior or receive other breaking changes across minor and patch version bumps. Experimental : Projects that are under active development and may change behavior or receive other breaking changes across minor releases. Community : a community-maintained project, not officially supported by the jsii core team .","title":"Toolchain"},{"location":"specification/1-introduction/","text":"Introduction This document provides a high level overview of jsii , starting with its design tenets. It introduces the concepts and components that compose jsii . Updating the Specification Introduction The jsii specification follows the guiding principles of an RFC. It is a living document that describes the current understanding of how the various components of jsii are operating, as well as the approaches used to ensure consistent behavior across the various supported languages. The document is hosted with the jsii codebase, making it easy to determine what specification was in place at the time of a give jsii release (by ways of referring to the vX.Y.Z git tag). A single version of the specification is considered active at any given time: the version of the specification that is represented on the HEAD commit of the main branch of the aws/jsii repository. The active specification must be the base version for any update proposal. The process to update the specification is intended to be as lightweight as possible, while ensuring sufficient conversation takes place before implementing significant (and breaking) changes. Since the process to update the specification is part of the specification itself, it is amenable to be changed following the process described in the currently active specification. Process While the general process for updating the specification is to create a GitHub pull request against the aws/jsii repository, the exact requirements for what should be included in the pull request vary depending on the type of update that is proposed: Changing Behavior describes the process to be followed when introducing changes to the behavior of any component of jsii : new features, breaking changes to existing features, ... Addressing Gaps is the process used for adding specification around existing but unspecified behavior. Trivial Changes explains how to propose changes that improve the specification without changing its meaning. Changing Behavior If the change is not backwards compatible (it is a breaking change to an existing feature, or it is a new feature that requires all runtime libraries implement support immediately), a new RFC should be created in the awslabs/aws-cdk-rfcs repository, following the RFC Process . This ensures enough time is spent considering alternatives to breaking changes, and to create consensus that the change is desirable before time is spent implementing it. Note While going through the RFC process upfront is strongly recommended , contributors may choose not to file an RFC for a behavior change. In this case however, any core maintainer may decide that an RFC is required and block the contribution until the RFC process has been followed. It is worth noting that a draft pull request with proposed modifications to the specification (and possibly a proof-of-concept implementation), can be extremely useful. When the RFC is ready , a GitHub pull request is created that must contain: Relevant additions or modifications to the specification documents Relevant additions or modifications to the compliance suite Implementation of the new behavior, including new or updated tests in all the language bindings The pull request's body must reference the RFC if there has been one, and otherwise must include all discussion necessary to explain the reasoning behind the proposal (including alternatives considered, risks, ...). Addressing Gaps Proposals that increase the specification's coverage (desribing behavior that already exists) are handled as GitHub pull requests that must contain the following elements: Relevant additions to the specification documents New compliance test(s) that enshrine the described behavior Implementation of the new compliance test(s) for all Generally Available language bindings The pull request body should provide pointers to any and all elements that can be used to verify that the behavior that is described is indeed what is currently implemented. Trivial Changes Proposal of trivial changes, such as correcting typos in the document, or re-phrasing elements of the specification without altering the meaning (typically to improve clarity) are handled in a simple GitHub pull request. Design Tenets (unless you know better ones) jsii APIs strive to feel idiomatic in all supported languages. jsii applications behave identically regardless of the language they are written in. It favors correctness over performance. jsii does not attempt to support all TypeScript idioms (many features of TypeScript cannot be expressed in some target languages). Unsupported idioms will cause a compile-time error to be emitted. When prohibiting an idiom, jsii strives to provide an error message that gives the user insight into why the pattern cannot be supported. jsii does not force API design opinions on the developer: Reserved names are limited to a minimum. TypeScript API design patterns that are known to result in poor developer experience when represented in other languages will cause warnings to be issued, but the developer is ultimately entitled to decide whether they want to take or leave the advice. jsii produces artifacts compatible with idiomatic tools whenever possible: Generated libraries can be easily published to the \"standard\" package repository for the language. Standard tools can be used to work with the generated libraries, and do not require any special configuration. Annotations Annotations are present in the jsii specification to provide additional information to the reader that is non-normative. Those take the form of block-quotes that use the following chart: Unimplemented Is used to annotate parts of the specification that are known to be partially or incorrectly implemented in the current releases. Those are known issues in the current implementation that will be addressed in the future. Question Is used to annotate open questions. They are typically in parts of the specification that is likely to change in future releases, and that may be good candidates for introducing RFCs. Danger Is used to draw the reader's attention on specific points. They are used primarily to help the reader identify areas of the specification that, when incorrectly implemented, may result in hard-to-troubleshoot bugs; or to identify behavior that is intentionally undefined. Info Is used to provide additional context which may not be obvious to the reader. They typically contain trivia that can help the reader understand the motivation for certain behaviors that are not always intuitive. Concepts jsii allows developers to author code once in TypeScript , while allowing use in a variety of other programming languages (including C# , Java and Python ). Assemblies The jsii Assembly document contains a specific representation of the API exported by the TypeScript module. Similar to a header file in the C++ world, it contains only information about the signatures of APIs (type names with method and property signatures, associated documentation elements, ...) and no implementation. The npm package produced as a result of compiling the TypeScript source remains the source of truth with respects to implementation of the API. Host & Kernel The jsii runtime architecture defines two processes: The host process runs the users' code native environment (a Java virtual machine, the .NET Runtime, ...). The kernel process hosts the JavaScript code from the standard npm package defined by the user (and their dependencies), which is loaded and managed by a standardized @jsii/kernel package. The host process is responsible for starting the kernel process as needed. A designated host runtime library provides helper functions that will perform the necessary initialization when needed, so the host app does not need to include any special boilerplate code. The two processes exchange messages over a designated communication channel (for example, using pipes), using a kernel API that is standardized in the jsii specification . Components Several tools are involved in making this possible: jsii is a modified TypeScript compiler. In addition to generating JavaScript code from the source, it produces a jsii Assembly document. jsii-pacmak generates language bindings from a package compiled using jsii . It generates code in host languages that expose the API declared in the jsii Assembly document. Host runtime libraries centralize features used by code generated by jsii-pacmak , such as primitives to interact with the kernel process, so that this code does not need to be duplicated in every generated module. @jsii/kernel (and @jsii/runtime ) provide the functionality exposed by the kernel process, and allow the host code to seamlessly interact with the JavaScript implementation.","title":"Introduction"},{"location":"specification/1-introduction/#introduction","text":"This document provides a high level overview of jsii , starting with its design tenets. It introduces the concepts and components that compose jsii .","title":"Introduction"},{"location":"specification/1-introduction/#updating-the-specification","text":"","title":"Updating the Specification"},{"location":"specification/1-introduction/#introduction_1","text":"The jsii specification follows the guiding principles of an RFC. It is a living document that describes the current understanding of how the various components of jsii are operating, as well as the approaches used to ensure consistent behavior across the various supported languages. The document is hosted with the jsii codebase, making it easy to determine what specification was in place at the time of a give jsii release (by ways of referring to the vX.Y.Z git tag). A single version of the specification is considered active at any given time: the version of the specification that is represented on the HEAD commit of the main branch of the aws/jsii repository. The active specification must be the base version for any update proposal. The process to update the specification is intended to be as lightweight as possible, while ensuring sufficient conversation takes place before implementing significant (and breaking) changes. Since the process to update the specification is part of the specification itself, it is amenable to be changed following the process described in the currently active specification.","title":"Introduction"},{"location":"specification/1-introduction/#process","text":"While the general process for updating the specification is to create a GitHub pull request against the aws/jsii repository, the exact requirements for what should be included in the pull request vary depending on the type of update that is proposed: Changing Behavior describes the process to be followed when introducing changes to the behavior of any component of jsii : new features, breaking changes to existing features, ... Addressing Gaps is the process used for adding specification around existing but unspecified behavior. Trivial Changes explains how to propose changes that improve the specification without changing its meaning.","title":"Process"},{"location":"specification/1-introduction/#changing-behavior","text":"If the change is not backwards compatible (it is a breaking change to an existing feature, or it is a new feature that requires all runtime libraries implement support immediately), a new RFC should be created in the awslabs/aws-cdk-rfcs repository, following the RFC Process . This ensures enough time is spent considering alternatives to breaking changes, and to create consensus that the change is desirable before time is spent implementing it. Note While going through the RFC process upfront is strongly recommended , contributors may choose not to file an RFC for a behavior change. In this case however, any core maintainer may decide that an RFC is required and block the contribution until the RFC process has been followed. It is worth noting that a draft pull request with proposed modifications to the specification (and possibly a proof-of-concept implementation), can be extremely useful. When the RFC is ready , a GitHub pull request is created that must contain: Relevant additions or modifications to the specification documents Relevant additions or modifications to the compliance suite Implementation of the new behavior, including new or updated tests in all the language bindings The pull request's body must reference the RFC if there has been one, and otherwise must include all discussion necessary to explain the reasoning behind the proposal (including alternatives considered, risks, ...).","title":"  Changing Behavior"},{"location":"specification/1-introduction/#addressing-gaps","text":"Proposals that increase the specification's coverage (desribing behavior that already exists) are handled as GitHub pull requests that must contain the following elements: Relevant additions to the specification documents New compliance test(s) that enshrine the described behavior Implementation of the new compliance test(s) for all Generally Available language bindings The pull request body should provide pointers to any and all elements that can be used to verify that the behavior that is described is indeed what is currently implemented.","title":"  Addressing Gaps"},{"location":"specification/1-introduction/#trivial-changes","text":"Proposal of trivial changes, such as correcting typos in the document, or re-phrasing elements of the specification without altering the meaning (typically to improve clarity) are handled in a simple GitHub pull request.","title":"  Trivial Changes"},{"location":"specification/1-introduction/#design-tenets-unless-you-know-better-ones","text":"jsii APIs strive to feel idiomatic in all supported languages. jsii applications behave identically regardless of the language they are written in. It favors correctness over performance. jsii does not attempt to support all TypeScript idioms (many features of TypeScript cannot be expressed in some target languages). Unsupported idioms will cause a compile-time error to be emitted. When prohibiting an idiom, jsii strives to provide an error message that gives the user insight into why the pattern cannot be supported. jsii does not force API design opinions on the developer: Reserved names are limited to a minimum. TypeScript API design patterns that are known to result in poor developer experience when represented in other languages will cause warnings to be issued, but the developer is ultimately entitled to decide whether they want to take or leave the advice. jsii produces artifacts compatible with idiomatic tools whenever possible: Generated libraries can be easily published to the \"standard\" package repository for the language. Standard tools can be used to work with the generated libraries, and do not require any special configuration.","title":"Design Tenets (unless you know better ones)"},{"location":"specification/1-introduction/#annotations","text":"Annotations are present in the jsii specification to provide additional information to the reader that is non-normative. Those take the form of block-quotes that use the following chart: Unimplemented Is used to annotate parts of the specification that are known to be partially or incorrectly implemented in the current releases. Those are known issues in the current implementation that will be addressed in the future. Question Is used to annotate open questions. They are typically in parts of the specification that is likely to change in future releases, and that may be good candidates for introducing RFCs. Danger Is used to draw the reader's attention on specific points. They are used primarily to help the reader identify areas of the specification that, when incorrectly implemented, may result in hard-to-troubleshoot bugs; or to identify behavior that is intentionally undefined. Info Is used to provide additional context which may not be obvious to the reader. They typically contain trivia that can help the reader understand the motivation for certain behaviors that are not always intuitive.","title":"Annotations"},{"location":"specification/1-introduction/#concepts","text":"jsii allows developers to author code once in TypeScript , while allowing use in a variety of other programming languages (including C# , Java and Python ).","title":"Concepts"},{"location":"specification/1-introduction/#assemblies","text":"The jsii Assembly document contains a specific representation of the API exported by the TypeScript module. Similar to a header file in the C++ world, it contains only information about the signatures of APIs (type names with method and property signatures, associated documentation elements, ...) and no implementation. The npm package produced as a result of compiling the TypeScript source remains the source of truth with respects to implementation of the API.","title":"Assemblies"},{"location":"specification/1-introduction/#host-kernel","text":"The jsii runtime architecture defines two processes: The host process runs the users' code native environment (a Java virtual machine, the .NET Runtime, ...). The kernel process hosts the JavaScript code from the standard npm package defined by the user (and their dependencies), which is loaded and managed by a standardized @jsii/kernel package. The host process is responsible for starting the kernel process as needed. A designated host runtime library provides helper functions that will perform the necessary initialization when needed, so the host app does not need to include any special boilerplate code. The two processes exchange messages over a designated communication channel (for example, using pipes), using a kernel API that is standardized in the jsii specification .","title":"Host &amp; Kernel"},{"location":"specification/1-introduction/#components","text":"Several tools are involved in making this possible: jsii is a modified TypeScript compiler. In addition to generating JavaScript code from the source, it produces a jsii Assembly document. jsii-pacmak generates language bindings from a package compiled using jsii . It generates code in host languages that expose the API declared in the jsii Assembly document. Host runtime libraries centralize features used by code generated by jsii-pacmak , such as primitives to interact with the kernel process, so that this code does not need to be duplicated in every generated module. @jsii/kernel (and @jsii/runtime ) provide the functionality exposed by the kernel process, and allow the host code to seamlessly interact with the JavaScript implementation.","title":"Components"},{"location":"specification/2-type-system/","text":"The jsii type system Preamble The base language for authoring jsii libraries for re-use from other languages is TypeScript , which compiles to JavaScript . Consequently, the base type system that jsii sources from is that of TypeScript . When used from another language than TypeScript or JavaScript , jsii libraries are running the JavaScript code in a child node process, and data is exchanged using JSON -based protocol. This document describes how TypeScript types map into the jsii type system. The API represented by the jsii assembly only covers declarations that are exported from the main file in the TypeScript project (as specified in the package.json file by the types attribute). Restrictions described in this document only apply to such declarations, the rest of the module can leverage any TypeScript feature. Basic Types Introduction In order to build useful programs, the simplest units of data need to be modeled: booleans, numbers, strings, etc... Those basic building blocks are the foundations on which APIs stand. jsii supports much of the same types that TypeScript and JavaScript support, although with notable differences. Boolean The jsii type system mirrors TypeScript 's boolean , which is the simplest primitive data types, with only two supported values: true and false . Number The jsii type system mirrors TypeScript 's number . All numbers are floating point values. String The jsii type system mirrors TypeScript 's string . Strings are used to represent textual data. List TypeScript arrays ( Array<T> , T[] , ReadonlyArray<T> and readonly T[] ) are represented as lists in the jsii type model. Lists are shared between the node process and the host process by-value, meaning a copy of the array is produced each time it is passed through the process boundary. Info Items in the list may be passed by-reference (according to their type's specification), in which case mutating operations performed on those may be visible across the process boundary. Find out more here Enum As in many languages, enum can be used to represent a group of related constants. While TypeScript enum entries are associated with a value that is either a string or a number , the jsii type system does not allow for those to be down-casted to their value type (e.g: a string -valued enum entry cannot be directly passed into a string parameter). Info Unlike in certain languages such as Java , enum types cannot declare new properties or methods. Find out more here Any and Unknown TypeScript defines two opaque types: any and unknown that can be used to represent a value of arbitrary type. The difference between them is that while any is assignable to any other type , unknown requires a type assertion or explicit cast to be performed before it can be assigned. Both of these types map to an Any primitive type in the jsii type system, and the subtle distinction between any and unknown is lost in the process. Info It is important to note that, contrary to the other types in the TypeScript type system, any and unknown types are inherently null -able. Void As in most languages, the void type is used to denote a method does not return anything. Find out more here Null and Undefined JavaScript differentiates undefined and null values. While undefined denotes that no value has been set, null denotes an intentional signal of there being no data . Most other programming languages (particularly statically typed languages) however lack this distinction, and the jsii type model consequently considers null and undefined are semantically equivalent. Info Unlike certain other programming languages, such as Java , TypeScript does not allow null (or undefined ) values unless the type signature expressedly supports that (with the exception of any and unknown , which are implicitly null -able, as was discussed earlier). Find out more here Object TypeScript 's object type denotes anything that is not a primitive type, meaning anything other than a number , string , boolean , bigint , symbol , null or undefined . In the jsii type model, object indicates a block of structured data that can be shared by-value across the process boundary. As a consequence, they may not include any method. Unimplemented This type is called Json in the current implementation. Question The by-value nature of object is problematic because TypeScript makes no guarantee with respects to the absence of methods on object , and properties may be dynamic. Find out more here Promises jsii supports asynchronous methods, and the TypeScript Promise<T> type has to be used as the result of async methods. Promises can only be used as the result type of methods, not as the type of a property or parameter. Unsupported TypeScript basic types Due to how such types cannot be represented in many other programming languages, the jsii type model does not support the following TypeScript entities: Tuples, a group of arbitrarily-typed values, often used as the result type for multi-valued functions. The never type, which is used as the return type of functions that will not yield control back to their invoker (infinite loops, process.exit() , ...). bigint and symbol don't have equivalents in many other programming languages and are generally of limited value in API design. Complex Types The goal of the jsii is to enable cross-language re-use of class libraries. TypeScript enables representing classic object-oriented concepts, such as classes and interfaces . The jsii type system supports some additional nuances on top of those, to better represent TypeScript and JavaScript idioms in a way that enables generating convenient APIs in other languages. Classes Exported TypeScript classes are represented in the jsii type system, with the following restrictions from plain TypeScript : Methods overloads are not supported. Overridden methods or properties must retain the exact same type signature as the one declared in a parent type. The jsii type system strictly enforces the Liskov substitution principle . Interfaces & Structs Exported TypeScript interfaces are interpreted as one of two entities in the jsii type system: If the interface name is prefixed with an I (e.g: ISomething ), it is interpreted as a behavioral interface . Otherwise (e.g: Something ), it is interpreted as a struct . Behavioral Interfaces Behavioral interfaces are the usual object-oriented interface: they can extend other behavioral interfaces , and can be extended by classes . They may however not extend structs . Structs Structs are used to model the JavaScript idiom of receiving options as an object literal passed as the last parameter of a function. They are a formal description of a bag of properties, and are not meant to be implemented by other types. Since those types are used as inputs, they can be handled as pure-data, immutable objects, and the following restrictions apply: A struct cannot declare any method : they must be kept behavior-free. All properties declared by a struct must be readonly . The values of the properties may however be mutable. Structs may extend one or more other structs , but cannot extend or be extended by behavioral interfaces , and may not be implemented by classes . Type Unions In certain cases, several different kinds of values are acceptable for a given parameter or return type. TypeScript models those cases using type unions , which are represented as TypeA | TypeB . The jsii type model supports those, however most other statically typed languages do not have such a concept, making those parameters or return values difficult to use from those languages, as the value has to be declared using the most generic reference type available (for example, in Java , those are returned as java.lang.Object ). When used as inputs (parameters, or properties of a struct ), it may be possible to generate method overloads that will allow for a convenient API in languages that support overloads. In general however, type unions are discouraged and should only be used when there is no alternative way to model the API. Find out more here Serialization Behavior When values are passed between the host process and the node process, they are serialized as JSON documents. They can be passed by value or by reference, depending on the type of the value as well as the declared type of the transfer point (method return type, property type, argument type, ...). The table below describes the serialization behavior applied for each possible declared type (rows) for a value of a given dynamic type (columns). The sign expresses cases that are illegal and should cause immediate failure. The term primitive encompasses boolean , string , and number . undefined Date primitive Array instance object void undefined undefined undefined undefined undefined undefined Date undefined Date primitive undefined Identity enum undefined Enum List undefined Array Map undefined Mapping interface undefined Reference Reference struct undefined Value class undefined Reference Reference any undefined Date Identity Array Reference Value or Reference In the case of object being passed though any , the value may be serialized by Value only if the value being passed does not have any method or dynamic accessor. Otherwise, it must be passed by Reference instead. Danger The serialization behavior around undefined values is affected by the optional attribute of the declared type. As discussed earlier, the any type is implicitly optional ; but all other types' serialization process will only allow serialization of undefined if they were declared optional . Array Serialization Arrays are serialized into the standard JSON representation for them. Each value in the array is serialized according to the behavior dictated by the declared element type of the list, combined with the dynamic type of the value itself. Date Serialization JSON has no standard expression for Date . A special JSON object representation is used to allow unambiguously conveying a date. The wrapper has a single key ( $jsii.date ) with the ISO 8601-1 UTC representation of the Date value: { \"$jsii.date\" : \"2020-01-20T14:04:00.000Z\" } Enum Serialization In JavaScript , enum entries are represented by their value equivalent. In order to support statically typed representations in other languages, these are serialized using a dedicated wrapper object, using a single key ( $jsii.enum ) with the fully qualified name of the enum entry (formatted as <enum type fqn>/<entry name> ): { \"$jsii.enum\" : \"@scope/module.EnumType/ENTRY_NAME\" } Identity Serialization The identity serialization is achieved by using the standard JSON representation of the primitive type. JSON strings are expressed using the UTF-8 character set. Mapping Serialization Key-value pairs are passed by-value between the processes and is wrapped using a single-key ( $jsii.map ) associated with the JSON representation of the encoded object; where values are serialized according to the behavior dictated by the element type of the mapping, combined with the dynamic type of the value itself: { \"$jsii.map\" : { \"foo\" : { \"date\" : { \"$jsii.date\" : \"2020-01-20T14:04:00.000Z\" }, \"map\" : { \"$jsii.map\" : {} } } } } Reference Serialization Objects serialized by reference are passed using a special object that provides sufficient information to tie back to the instance within its owning process. It includes a $jsii.byref key associated with a string that uniquely identifies the instance, and an optional $jsii.interfaces key that provides a list of interfaces that the object implements. { \"$jsii.byref\" : \"@scope/module.Foo@1337\" , \"$jsii.interfaces\" : [ \"@scope/module.IBar\" , \"@scope/module.IBaz\" ] } Value Serialization Structs can be serialized by-value. In those cases, the value is wrapped using a special object that encapsulates the type information for the provided data as well as the struct 's members. The wrapper uses a single $jsii.struct key with a fqn key that indicates the fully qualified name of the struct type, and a data key that contains the members of the struct , serialized according to the behavior described in this document. { \"$jsii.struct\" : { \"fqn\" : \"@scope/module.StructType\" , \"data\" : { \"enumValue\" : { \"$jsii.enum\" : \"@scope/module.EnumType.ENTRY_NAME\" }, \"stringProperty\" : \"Hello, I'm a string!\" } } } Submodules Overview Typescript allows grouping declarations together in namespaces , which are interpreted by jsii as submodules . Submodules names are the fully qualified name of the namespace from the package's root (if a package foo defines a namespace ns1 , which itself contains ns2 , the submodule for ns2 will be named foo.ns1.ns2 ). Submodules are delcared in the jsii assembly under the submodules key. This is also where specific configuration is registered, if different from the parent submodule or package. Submodules are hierarchical, and their fully qualified name is representative of the relationship. For example the assm.foo.bar submodule is considered to be nested under the assm.foo submodule. Restrictions Submodules cannot be involved in dependency cycles. While it is possible to build such cycles in JavaScript , that configuration cannot be reliably reprensented in certain other programming languages (e.g: Python ). Unimplemented jsii does not currently check for circular submodule dependencies. Invalid dependency patterns may result in errors at code generation by jsii-pacmak , or at runtime. Since this would result in ambiguity that cannot be consistently resolved, a given type can only be exported as part of one submodule . Declaration There are two supported ways to introduce submodules : Using the namespaced export syntax: export * as ns from './module' ; Using an explicit namespace declaration: export namespace ns { /* ... */ } Submodules declared using the export * as ns from './module'; syntax can be documented using a markdown document located at ./module/README.md . Unimplemented The ./module/README.md file support is not yet implemented. Submodule Configuration In languages where this is relevant (e.g: Python ), submodules are rendered as native submodules . In languages where a namespace system exists ( Java uses packages , C# uses namespaces , ...), submodules are rendered using that. By default, submodule names are rendered appropriately in the target language (this typically involves adjusting the case of submodule name fragments to the idiomatic form in the language). In certain cases however, a developer can choose to use a different configuration by defining the submodule using the namespaced-export syntax ( export * as namespace from './module-name'; ) by placing a .jsiirc.json file next to the entry point of the namespaced module. For example, if ./module-name 's entry point is foo/bar/module-name/index.ts , the submodule configuration resides in foo/bar/module-name/.jsiirc.json . Since submodules are hierarchical, the configuration of a given submodule defines the default configuration of submodules nested under it. Code Generation In order to generate code in various programming languages, jsii-pacmak needs configuration that provides naming directives (e.g: Java package names, C# namespaces, Python module names, ...). This configuration is language-specific and each language implementation specifies and documents its own configuration schema. Configuration is sourced in the package.json file at the root of the npm package, under the special jsii key. The general schema is described in the configuration document. Unimplemented There is a proposition to allow this configuration to be placed in a .jsiirc.json file, which would take precedence over what is specified in package.json . Submodules introduced using the export * as ns from './module'; syntax would then be able to define submodule -local configuration using the ./module/.jsiirc.json file. References The TypeScript Handbook describes the language's type system and syntax elements that serve as the basis for the jsii type system. Additionally, the JavaScript type system is described in the JavaScript Fundamentals document.","title":"The jsii type system"},{"location":"specification/2-type-system/#the-jsii-type-system","text":"","title":"The jsii type system"},{"location":"specification/2-type-system/#preamble","text":"The base language for authoring jsii libraries for re-use from other languages is TypeScript , which compiles to JavaScript . Consequently, the base type system that jsii sources from is that of TypeScript . When used from another language than TypeScript or JavaScript , jsii libraries are running the JavaScript code in a child node process, and data is exchanged using JSON -based protocol. This document describes how TypeScript types map into the jsii type system. The API represented by the jsii assembly only covers declarations that are exported from the main file in the TypeScript project (as specified in the package.json file by the types attribute). Restrictions described in this document only apply to such declarations, the rest of the module can leverage any TypeScript feature.","title":"Preamble"},{"location":"specification/2-type-system/#basic-types","text":"","title":"Basic Types"},{"location":"specification/2-type-system/#introduction","text":"In order to build useful programs, the simplest units of data need to be modeled: booleans, numbers, strings, etc... Those basic building blocks are the foundations on which APIs stand. jsii supports much of the same types that TypeScript and JavaScript support, although with notable differences.","title":"Introduction"},{"location":"specification/2-type-system/#boolean","text":"The jsii type system mirrors TypeScript 's boolean , which is the simplest primitive data types, with only two supported values: true and false .","title":"Boolean"},{"location":"specification/2-type-system/#number","text":"The jsii type system mirrors TypeScript 's number . All numbers are floating point values.","title":"Number"},{"location":"specification/2-type-system/#string","text":"The jsii type system mirrors TypeScript 's string . Strings are used to represent textual data.","title":"String"},{"location":"specification/2-type-system/#list","text":"TypeScript arrays ( Array<T> , T[] , ReadonlyArray<T> and readonly T[] ) are represented as lists in the jsii type model. Lists are shared between the node process and the host process by-value, meaning a copy of the array is produced each time it is passed through the process boundary. Info Items in the list may be passed by-reference (according to their type's specification), in which case mutating operations performed on those may be visible across the process boundary. Find out more here","title":"List"},{"location":"specification/2-type-system/#enum","text":"As in many languages, enum can be used to represent a group of related constants. While TypeScript enum entries are associated with a value that is either a string or a number , the jsii type system does not allow for those to be down-casted to their value type (e.g: a string -valued enum entry cannot be directly passed into a string parameter). Info Unlike in certain languages such as Java , enum types cannot declare new properties or methods. Find out more here","title":"Enum"},{"location":"specification/2-type-system/#any-and-unknown","text":"TypeScript defines two opaque types: any and unknown that can be used to represent a value of arbitrary type. The difference between them is that while any is assignable to any other type , unknown requires a type assertion or explicit cast to be performed before it can be assigned. Both of these types map to an Any primitive type in the jsii type system, and the subtle distinction between any and unknown is lost in the process. Info It is important to note that, contrary to the other types in the TypeScript type system, any and unknown types are inherently null -able.","title":"Any and Unknown"},{"location":"specification/2-type-system/#void","text":"As in most languages, the void type is used to denote a method does not return anything. Find out more here","title":"Void"},{"location":"specification/2-type-system/#null-and-undefined","text":"JavaScript differentiates undefined and null values. While undefined denotes that no value has been set, null denotes an intentional signal of there being no data . Most other programming languages (particularly statically typed languages) however lack this distinction, and the jsii type model consequently considers null and undefined are semantically equivalent. Info Unlike certain other programming languages, such as Java , TypeScript does not allow null (or undefined ) values unless the type signature expressedly supports that (with the exception of any and unknown , which are implicitly null -able, as was discussed earlier). Find out more here","title":"Null and Undefined"},{"location":"specification/2-type-system/#object","text":"TypeScript 's object type denotes anything that is not a primitive type, meaning anything other than a number , string , boolean , bigint , symbol , null or undefined . In the jsii type model, object indicates a block of structured data that can be shared by-value across the process boundary. As a consequence, they may not include any method. Unimplemented This type is called Json in the current implementation. Question The by-value nature of object is problematic because TypeScript makes no guarantee with respects to the absence of methods on object , and properties may be dynamic. Find out more here","title":"Object"},{"location":"specification/2-type-system/#promises","text":"jsii supports asynchronous methods, and the TypeScript Promise<T> type has to be used as the result of async methods. Promises can only be used as the result type of methods, not as the type of a property or parameter.","title":"Promises"},{"location":"specification/2-type-system/#unsupported-typescript-basic-types","text":"Due to how such types cannot be represented in many other programming languages, the jsii type model does not support the following TypeScript entities: Tuples, a group of arbitrarily-typed values, often used as the result type for multi-valued functions. The never type, which is used as the return type of functions that will not yield control back to their invoker (infinite loops, process.exit() , ...). bigint and symbol don't have equivalents in many other programming languages and are generally of limited value in API design.","title":"Unsupported TypeScript basic types"},{"location":"specification/2-type-system/#complex-types","text":"The goal of the jsii is to enable cross-language re-use of class libraries. TypeScript enables representing classic object-oriented concepts, such as classes and interfaces . The jsii type system supports some additional nuances on top of those, to better represent TypeScript and JavaScript idioms in a way that enables generating convenient APIs in other languages.","title":"Complex Types"},{"location":"specification/2-type-system/#classes","text":"Exported TypeScript classes are represented in the jsii type system, with the following restrictions from plain TypeScript : Methods overloads are not supported. Overridden methods or properties must retain the exact same type signature as the one declared in a parent type. The jsii type system strictly enforces the Liskov substitution principle .","title":"Classes"},{"location":"specification/2-type-system/#interfaces-structs","text":"Exported TypeScript interfaces are interpreted as one of two entities in the jsii type system: If the interface name is prefixed with an I (e.g: ISomething ), it is interpreted as a behavioral interface . Otherwise (e.g: Something ), it is interpreted as a struct .","title":"Interfaces &amp; Structs"},{"location":"specification/2-type-system/#behavioral-interfaces","text":"Behavioral interfaces are the usual object-oriented interface: they can extend other behavioral interfaces , and can be extended by classes . They may however not extend structs .","title":"Behavioral Interfaces"},{"location":"specification/2-type-system/#structs","text":"Structs are used to model the JavaScript idiom of receiving options as an object literal passed as the last parameter of a function. They are a formal description of a bag of properties, and are not meant to be implemented by other types. Since those types are used as inputs, they can be handled as pure-data, immutable objects, and the following restrictions apply: A struct cannot declare any method : they must be kept behavior-free. All properties declared by a struct must be readonly . The values of the properties may however be mutable. Structs may extend one or more other structs , but cannot extend or be extended by behavioral interfaces , and may not be implemented by classes .","title":"Structs"},{"location":"specification/2-type-system/#type-unions","text":"In certain cases, several different kinds of values are acceptable for a given parameter or return type. TypeScript models those cases using type unions , which are represented as TypeA | TypeB . The jsii type model supports those, however most other statically typed languages do not have such a concept, making those parameters or return values difficult to use from those languages, as the value has to be declared using the most generic reference type available (for example, in Java , those are returned as java.lang.Object ). When used as inputs (parameters, or properties of a struct ), it may be possible to generate method overloads that will allow for a convenient API in languages that support overloads. In general however, type unions are discouraged and should only be used when there is no alternative way to model the API. Find out more here","title":"Type Unions"},{"location":"specification/2-type-system/#serialization-behavior","text":"When values are passed between the host process and the node process, they are serialized as JSON documents. They can be passed by value or by reference, depending on the type of the value as well as the declared type of the transfer point (method return type, property type, argument type, ...). The table below describes the serialization behavior applied for each possible declared type (rows) for a value of a given dynamic type (columns). The sign expresses cases that are illegal and should cause immediate failure. The term primitive encompasses boolean , string , and number . undefined Date primitive Array instance object void undefined undefined undefined undefined undefined undefined Date undefined Date primitive undefined Identity enum undefined Enum List undefined Array Map undefined Mapping interface undefined Reference Reference struct undefined Value class undefined Reference Reference any undefined Date Identity Array Reference Value or Reference In the case of object being passed though any , the value may be serialized by Value only if the value being passed does not have any method or dynamic accessor. Otherwise, it must be passed by Reference instead. Danger The serialization behavior around undefined values is affected by the optional attribute of the declared type. As discussed earlier, the any type is implicitly optional ; but all other types' serialization process will only allow serialization of undefined if they were declared optional .","title":"Serialization Behavior"},{"location":"specification/2-type-system/#array-serialization","text":"Arrays are serialized into the standard JSON representation for them. Each value in the array is serialized according to the behavior dictated by the declared element type of the list, combined with the dynamic type of the value itself.","title":"Array Serialization"},{"location":"specification/2-type-system/#date-serialization","text":"JSON has no standard expression for Date . A special JSON object representation is used to allow unambiguously conveying a date. The wrapper has a single key ( $jsii.date ) with the ISO 8601-1 UTC representation of the Date value: { \"$jsii.date\" : \"2020-01-20T14:04:00.000Z\" }","title":"Date Serialization"},{"location":"specification/2-type-system/#enum-serialization","text":"In JavaScript , enum entries are represented by their value equivalent. In order to support statically typed representations in other languages, these are serialized using a dedicated wrapper object, using a single key ( $jsii.enum ) with the fully qualified name of the enum entry (formatted as <enum type fqn>/<entry name> ): { \"$jsii.enum\" : \"@scope/module.EnumType/ENTRY_NAME\" }","title":"Enum Serialization"},{"location":"specification/2-type-system/#identity-serialization","text":"The identity serialization is achieved by using the standard JSON representation of the primitive type. JSON strings are expressed using the UTF-8 character set.","title":"Identity Serialization"},{"location":"specification/2-type-system/#mapping-serialization","text":"Key-value pairs are passed by-value between the processes and is wrapped using a single-key ( $jsii.map ) associated with the JSON representation of the encoded object; where values are serialized according to the behavior dictated by the element type of the mapping, combined with the dynamic type of the value itself: { \"$jsii.map\" : { \"foo\" : { \"date\" : { \"$jsii.date\" : \"2020-01-20T14:04:00.000Z\" }, \"map\" : { \"$jsii.map\" : {} } } } }","title":"Mapping Serialization"},{"location":"specification/2-type-system/#reference-serialization","text":"Objects serialized by reference are passed using a special object that provides sufficient information to tie back to the instance within its owning process. It includes a $jsii.byref key associated with a string that uniquely identifies the instance, and an optional $jsii.interfaces key that provides a list of interfaces that the object implements. { \"$jsii.byref\" : \"@scope/module.Foo@1337\" , \"$jsii.interfaces\" : [ \"@scope/module.IBar\" , \"@scope/module.IBaz\" ] }","title":"Reference Serialization"},{"location":"specification/2-type-system/#value-serialization","text":"Structs can be serialized by-value. In those cases, the value is wrapped using a special object that encapsulates the type information for the provided data as well as the struct 's members. The wrapper uses a single $jsii.struct key with a fqn key that indicates the fully qualified name of the struct type, and a data key that contains the members of the struct , serialized according to the behavior described in this document. { \"$jsii.struct\" : { \"fqn\" : \"@scope/module.StructType\" , \"data\" : { \"enumValue\" : { \"$jsii.enum\" : \"@scope/module.EnumType.ENTRY_NAME\" }, \"stringProperty\" : \"Hello, I'm a string!\" } } }","title":"Value Serialization"},{"location":"specification/2-type-system/#submodules","text":"","title":"Submodules"},{"location":"specification/2-type-system/#overview","text":"Typescript allows grouping declarations together in namespaces , which are interpreted by jsii as submodules . Submodules names are the fully qualified name of the namespace from the package's root (if a package foo defines a namespace ns1 , which itself contains ns2 , the submodule for ns2 will be named foo.ns1.ns2 ). Submodules are delcared in the jsii assembly under the submodules key. This is also where specific configuration is registered, if different from the parent submodule or package. Submodules are hierarchical, and their fully qualified name is representative of the relationship. For example the assm.foo.bar submodule is considered to be nested under the assm.foo submodule.","title":"Overview"},{"location":"specification/2-type-system/#restrictions","text":"Submodules cannot be involved in dependency cycles. While it is possible to build such cycles in JavaScript , that configuration cannot be reliably reprensented in certain other programming languages (e.g: Python ). Unimplemented jsii does not currently check for circular submodule dependencies. Invalid dependency patterns may result in errors at code generation by jsii-pacmak , or at runtime. Since this would result in ambiguity that cannot be consistently resolved, a given type can only be exported as part of one submodule .","title":"Restrictions"},{"location":"specification/2-type-system/#declaration","text":"There are two supported ways to introduce submodules : Using the namespaced export syntax: export * as ns from './module' ; Using an explicit namespace declaration: export namespace ns { /* ... */ } Submodules declared using the export * as ns from './module'; syntax can be documented using a markdown document located at ./module/README.md . Unimplemented The ./module/README.md file support is not yet implemented.","title":"Declaration"},{"location":"specification/2-type-system/#submodule-configuration","text":"In languages where this is relevant (e.g: Python ), submodules are rendered as native submodules . In languages where a namespace system exists ( Java uses packages , C# uses namespaces , ...), submodules are rendered using that. By default, submodule names are rendered appropriately in the target language (this typically involves adjusting the case of submodule name fragments to the idiomatic form in the language). In certain cases however, a developer can choose to use a different configuration by defining the submodule using the namespaced-export syntax ( export * as namespace from './module-name'; ) by placing a .jsiirc.json file next to the entry point of the namespaced module. For example, if ./module-name 's entry point is foo/bar/module-name/index.ts , the submodule configuration resides in foo/bar/module-name/.jsiirc.json . Since submodules are hierarchical, the configuration of a given submodule defines the default configuration of submodules nested under it.","title":"Submodule Configuration"},{"location":"specification/2-type-system/#code-generation","text":"In order to generate code in various programming languages, jsii-pacmak needs configuration that provides naming directives (e.g: Java package names, C# namespaces, Python module names, ...). This configuration is language-specific and each language implementation specifies and documents its own configuration schema. Configuration is sourced in the package.json file at the root of the npm package, under the special jsii key. The general schema is described in the configuration document. Unimplemented There is a proposition to allow this configuration to be placed in a .jsiirc.json file, which would take precedence over what is specified in package.json . Submodules introduced using the export * as ns from './module'; syntax would then be able to define submodule -local configuration using the ./module/.jsiirc.json file.","title":"Code Generation"},{"location":"specification/2-type-system/#references","text":"The TypeScript Handbook describes the language's type system and syntax elements that serve as the basis for the jsii type system. Additionally, the JavaScript type system is described in the JavaScript Fundamentals document.","title":"References"},{"location":"specification/3-kernel-api/","text":"The jsii kernel API This document describes the API for the @jsii/kernel module, which is to be used by all host libraries. It provides the fundamental features necessary for host processes to interact with the original module's code. Note Currently, @jsii/kernel contains the bulk of the logic, however a separate @jsii/runtime package owns the dialogue between the host and kernel processes. The @jsii/runtime is a very thin glue layer and it will eventually be merged into @jsii/kernel . Errors Most of the calls described in this document may result in an error being raised. It is the responsibility of the host runtime library to deal with such errors correctly: action retries, propagate the error to the host app's code, and so on. Error responses are signaled by the error key: export interface ErrorResponse { /** A simple message describing what happened. */ message : string ; /** Whenever possible, the stack trace of the error. */ stack? : string ; } Where possible, the host runtime libraries should make sure to affix their own stack trace information where relevant to the kernel process's stack trace when such errors are propagated to host app's code, in order to offer as much relevant context information as possible. Initialization - the hello message The host library is responsible for spawning the node process that will run the original module's code. This node process runs the @jsii/kernel application, and API messages are exchanged via the node processes' standard input and output pipes. Upon initialization, the @jsii/kernel process introduces itself to the host application by emitting a single JSON message: { \"hello\" : \"@jsii/runtime@0.21.1\" } Any additional key present on the hello message will be silently ignored by a host library that does not know how to process it, ensuring forward compatibility of this message, if and when new attributes are added. Note In the future, this message may be augmented with additional keys to enable feature negotiation between the host application and the @jsii/kernel . Teardown - the exit message The host library should send the exit message when it no longer needs the @jsii/kernel . This message enables the @jsii/kernel to trigger clean-up operations, such as getting rid of temporary directories, in order to avoid littering the temporary directory with leftover files. The exit message has the following schema: interface Exit { /** The exit code the `@jsii/kernel` process should return. Typically `0`. */ readonly exit : number ; } Important Once the exit message has been sent, no more data should be sent through to the @jsii/kernel process. The request stream should be closed as soon as the exit message was sent. Additional data may however be received from the @jsii/kernel that is intended to the STDOUT or STDERR console streams. General Kernel API Once the hello handshake is complete, a sequence of request and responses are exchanged with the @jsii/kernel . Requests take the form of JSON-encoded messages that all follow the following pattern: interface Request { /** * This field discriminates the various request types. */ api : | 'load' // Loading jsii assemblies into the Kernel | 'naming' // Obtaining naming information for loaded assemblies | 'stats' // Obtaining statistics about the Kernel usage | 'create' // Creating objects | 'del' // Destroying objects | 'invoke' | 'sinvoke' // Invoking methods (and static methods) | 'get' | 'sget' // Invoking getters (and static getters) | 'set' | 'sset' // Invoking setters (and static setters) | 'begin' | 'end' ; // Asynchronous method invocation // ... request-type specific fields ... } Loading jsii assemblies into the Kernel Before any jsii type can be used, the assembly that provides it must be loaded into the kernel. Similarly, all dependencies of a given jsii module must have been loaded into the kernel before the module itself can be loaded (the @jsii/kernel does not perform any kind of dependency resolution). Loading new assemblies into the @jsii/kernel is done using the load API: interface LoadRequest { /** The name of the assembly being loaded */ name : string ; /** The version of the assembly being loaded */ version : string ; /** The local path to the npm package for the assembly */ tarball : string ; // The discriminator api : 'load' ; } The response to the load call provides some high-level information pertaining to the loaded assembly, which may be used by the host app to validate the result of the operation: interface LoadResponse { /** The name of the assembly that was just loaded */ assembly : string ; /** The number of types the assembly declared */ types : number ; } Once a module is loaded, all the types it declares immediately become available. Obtaining naming information for loaded assemblies In certain cases, host runtime libraries may need to obtain naming information from assemblies in order to determine the translation table from a jsii fully-qualified name to a host -native name. This can be retrieved using the naming call: export interface NamingRequest { /** The name of the assembly for which naming is requested */ assembly : string ; // The discriminator api : 'naming' ; } In response to the naming call, the @jsii/kernel returns the configuration block for each language supported by the named assembly : export interface NamingResponse { /** The naming information for the requested assembly. */ naming : { /** * For each language, provides the jsii configuration block. The content of * this configuration block is specified by each language implementation. */ [ language : string ] : { [ key : string ] : any }; }; } Obtaining statistics about the Kernel usage The stats call can be used to obtain information about the current Kernel instance, which can be leveraged by unit tests or in order to produce metrics for tracking the health of a long-running jsii app. export interface StatsRequest { // The discriminator api : 'stats' ; } The response to the stats call contains synthetic information about the current state of the Kernel : export interface StatsResponse { /** The number of object reference currently tracked by the Kernel */ objectCount : number ; } Creating objects Most jsii workflows start with creating instances of objects. This can mean creating a pure JavaScript object, instantiating a sub-class of some JavaScript class, or even creating a pure- host instance that implements a collection of behavioral interfaces . Creating objects is achieved using the create API, which accepts the following parameters: interface CreateRequest { /** The jsii fully qualified name of the class */ fqn : string ; /** Any arguments to provide to the constructor */ args? : any []; /** Additional interfaces implemented in the host app */ interfaces? : string []; /** Any methods or property overridden in the host app */ overrides? : Override []; // The discriminator api : 'create' ; } The response to the object call is a decorated ObjectReference object (which is a common parameter to other calls in the @jsii/kernel API, used to refer to a particular instance): interface ObjectReference { /** A handle that uniquely idenfies an instance */ '$jsii.byref' : string ; } interface CreateResponse extends ObjectReference { /** The list of interfaces implemented by the instance */ '$jsii.interfaces' ? : string []; } The value of the '$jsii.byref' field of the ObjectReference type is formatted in the following way: @aws-cdk/core.Stack@10003 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u252c\u2500\u2518 \u2502 \u2514\u2500 Opaque numeric identifier \u2514\u2500 Object instance's base class' jsii fully qualified name The first part of the reference identifier can have the special un-qualified value Object to denote the absence of a jsii -known base class (for example when the object only implements a jsii interface). Additional Interfaces Sometimes, the host app will extend a jsii class and implement new jsii interfaces that were not present on the original type. Such interfaces must be declared by providing their jsii fully qualified name as an entry in the interfaces list. Providing interfaces in this list that are implicitly present from another delcaration (either because they are already implemented by the class denoted by the fqn field, or because another entry in the interfaces list extends it) is valid, but not necessary. The @jsii/kernel is responsible for correctly handling redundant declarations. Danger While declared interfaces may contain redundant declarations of members already declared by other interfaces or by the type denoted by fqn , undefined behavior results if any such declaration is not identical to the others (e.g: property foo declared with type boolean on one of the interfaces , and with type string on another). Overrides For any method that is implemented or overridden from the host app, the create call must specify an override entry. This will inform the Kernel that calls to these methods must be relayed to the host app for execution, instead of executing the original library's version. An optional cookie string can be provided. This string will be recorded on the Javascript proxying implementation, and will be provided to the host app with any callback request. This information can be used, for example, to improve the performance of implementation lookups in the host app, where the necessary reflection calls would otherwise be prohibitively expensive. Override declarations adhere to the following schema: interface MethodOverride { /** The name of the overridden method */ method : string ; /** An arbitrary override cookie string */ cookie? : string ; } interface PropertyOverride { /** The name of the overridden property */ property : string ; /** An arbitrary override cookie string */ cookie? : string ; } type Override = MethodOverride | PropertyOverride ; A note about callbacks All @jsii/runtime calls that interact with object instances (that is, any call except for load , naming and stats ; as well as the del call since jsii does not support customized destructors or finalizers) may result in the need to execute code that is defined in the host app, when the code path traverses a method or property that was implemented or overridden in the host app. Such cases will result in a callback request substituting itself to the response of the original call being made; execution of which will resume once the callback response is provided. A callback request is sent from the @jsii/kernel 's node process to the host app and has the following schema: interface CallbackRequest { /** Callback requests are identified by the presence of the `callback` key */ callback : Callback ; } interface CallbackBase { /** A unique identifier for this callback request */ cbid : string ; /** The object on which the callback must be executed */ objref : ObjectReference ; /** The callback cookie, if one was specified */ cookie? : string ; } interface InvokeCallback extends CallbackBase { /** The name of the host method to be invoked */ method : string ; } interface GetCallback extends CallbackBase { /** The name of the property to be read */ property : string ; } interface SetCallback extends CallbackBase { /** The name of the property to be written to */ property : string ; /** The value to be set */ value : any ; } type Callback = InvokeCallback | GetCallback | SetCallback ; In order to fulfill the callback request, the host app may need to perform futher API calls (loading new assemblies, creating new instances, invoking methods - including delegating to the super implementation, ...). Such calls will behave as they otherwise would (including the possible introduction of further callback requests). Once the host app has fulfilled the request, it must signal the result of that execution back to the @jsii/kernel process by using the complete call: interface CompleteBase { /** The callback ID from the corresponding request */ cbid : string ; // The discriminator api : `complete` ; } interface CallbackSuccess extends CompleteBase { /** The result of the execution (`undefined` if void) */ result : any ; } interface CallbackFailure extends CompleteBase { /** The error that was raised during fulfillment */ err : string ; } type CompleteRequest = CallbackSuccess | CallbackFailure ; As discussed earlier, the response to the complete call is the result of resuming execution of the code path that triggered the callback request. This may be another callback request, or the final result of that call. The callbacks call may be used to determine the list of all outstanding callback requests: interface CallbacksRequest { // The discriminator api : 'callbacks' ; } This call results in a list of outstanding callbacks: interface CallbacksResponse { /** The list of outstanding callback requests */ callbacks : Callback []; } Destroying Objects Once the host app no longer needs a particular object, it can be discarded. This can happen for example when the host reference to an object is garbage collected or freed. In order to allow the JavaScript process to also reclaim the associated memory footprint, the del API must be used: interface DelRequest { /** The object reference that can be released */ objref : ObjectReference ; // The discriminator api : 'del' ; } Danger Failure to use the del API will result in memory leakage as the JavaScript process accumulates garbage in its Kernel instance. This can eventually result in a Javascript heap out of memory error, and the abnormal termination of the node process, and consequently of the host app. Unimplemented The existing host runtime libraries do not implement this behavior! Question There is currently no provision for the node process to inform the host app about object references it dropped. This mechanism is necessary in order to support garbage collection of resources that involve host -implemented code (in such cases, the host app must hold on to any instance it passed to JavaScript until it is no longer reachable from there). Upon successfully deleting an object reference, the @jsii/kernel will return an empty response object: export interface DelResponse {} Invoking methods (and static methods) Invoking methods is done via the invoke call: interface InvokeRequest { /** The object reference on which a method is invoked */ objref : ObjectReference ; /** The name of the method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'invoke' ; } Static method invocations do not have a receiving instance, and instead are implemented by way of the sinvoke call: interface StaticInvokeRequest { /** The jsii fully qualified name of the declaring type */ fqn : string ; /** The name of the static method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'sinvoke' ; } Note that, unlike in certain programming languages such as Java , it is illegal to attempt invoking a static method on the static type of some instance using the invoke call. All static invocations must be done using sinvoke . Both the invoke and sinvoke calls result in the same response: interface InvokeResponse { /** The result of the method invocation. */ result : any ; } When the method's return type is void , the result value should typically be undefined , however it may not be ?? ( TypeScript may in certain circumstances allow returning a value from a void method): the host app should ignore such values. Asynchronous method invocation The invoke call can only be used to invoke synchronous methods. In order to invoke asynchronous methods, the begin and end calls must be used instead. Once the host app has entered an asynchronous workflow (after it makes the first begin call), and until it has completed all asynchronous operations (after all begin class are matched with an end call), no synchronous operation (including synchronous callbacks) may be initiated. interface BeginRequest { /** The object reference on which an asynchronous method is invoked */ objref : ObjectReference ; /** The name of the method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'begin' ; } Question There is no static form of this call. Should there be one? The begin call results in a promise being made: interface BeginResponse { /** * An opaque string that uniquely idenfies the promised result of this * invocation. */ promiseid : string ; } Whenever the host app needs to obtain the promised value (possibly in a blocking way), it makes the corresponding end call: interface EndRequest { /** The promiseid that was returned from the corresponding `begin` call. */ promiseid : string ; // The discriminator api : 'end' ; } This will result in the promise being awaited and then resolved: interface EndResponse { /** The resolved value of the promise */ result : any ; } Danger All begin calls must be matched with an end call. Failure to do so may result in unhandled promise rejections that might cause the application to terminate in certain environments. Invoking getters (and static getters) In order to obtain the value of properties, the get call is used: interface GetRequest { /** The object reference on which a poperty is read */ objref : ObjectReference ; /** The name of the property being read */ property : string ; // The discriminator api : 'get' ; } When operating on static properties, or in order to obtain the value of enum constants, the sget API must be used instead: interface StaticGetRequest { /** The jsii fully qualified name of the declaring type */ fqn : ObjectReference ; /** The name of the property being read */ property : string ; // The discriminator api : 'sget' ; } Both the get and sget calls result in the same response: interface GetResponse { /** The value of the property. */ result : any ; } Invoking setters (and static setters) In order to change the value of a property, the set call is used: interface SetRequest { /** The object reference on which a poperty is written to */ objref : ObjectReference ; /** The name of the property being written to */ property : string ; /** The value that is written to the property */ value : any ; // The discriminator api : 'set' ; } When operating on static properties, the sset API must be used instead: interface StaticSetRequest { /** The jsii fully qualified name of the declaring type */ fqn : ObjectReference ; /** The name of the property being written to */ property : string ; /** The value that is written to the property */ value : any ; // The discriminator api : 'sset' ; } Both the set and sset calls result in the same response, which is an empty object: interface SetResponse {}","title":"The jsii kernel API"},{"location":"specification/3-kernel-api/#the-jsii-kernel-api","text":"This document describes the API for the @jsii/kernel module, which is to be used by all host libraries. It provides the fundamental features necessary for host processes to interact with the original module's code. Note Currently, @jsii/kernel contains the bulk of the logic, however a separate @jsii/runtime package owns the dialogue between the host and kernel processes. The @jsii/runtime is a very thin glue layer and it will eventually be merged into @jsii/kernel .","title":"The jsii kernel API"},{"location":"specification/3-kernel-api/#errors","text":"Most of the calls described in this document may result in an error being raised. It is the responsibility of the host runtime library to deal with such errors correctly: action retries, propagate the error to the host app's code, and so on. Error responses are signaled by the error key: export interface ErrorResponse { /** A simple message describing what happened. */ message : string ; /** Whenever possible, the stack trace of the error. */ stack? : string ; } Where possible, the host runtime libraries should make sure to affix their own stack trace information where relevant to the kernel process's stack trace when such errors are propagated to host app's code, in order to offer as much relevant context information as possible.","title":"Errors"},{"location":"specification/3-kernel-api/#initialization-the-hello-message","text":"The host library is responsible for spawning the node process that will run the original module's code. This node process runs the @jsii/kernel application, and API messages are exchanged via the node processes' standard input and output pipes. Upon initialization, the @jsii/kernel process introduces itself to the host application by emitting a single JSON message: { \"hello\" : \"@jsii/runtime@0.21.1\" } Any additional key present on the hello message will be silently ignored by a host library that does not know how to process it, ensuring forward compatibility of this message, if and when new attributes are added. Note In the future, this message may be augmented with additional keys to enable feature negotiation between the host application and the @jsii/kernel .","title":"Initialization - the hello message"},{"location":"specification/3-kernel-api/#teardown-the-exit-message","text":"The host library should send the exit message when it no longer needs the @jsii/kernel . This message enables the @jsii/kernel to trigger clean-up operations, such as getting rid of temporary directories, in order to avoid littering the temporary directory with leftover files. The exit message has the following schema: interface Exit { /** The exit code the `@jsii/kernel` process should return. Typically `0`. */ readonly exit : number ; } Important Once the exit message has been sent, no more data should be sent through to the @jsii/kernel process. The request stream should be closed as soon as the exit message was sent. Additional data may however be received from the @jsii/kernel that is intended to the STDOUT or STDERR console streams.","title":"Teardown - the exit message"},{"location":"specification/3-kernel-api/#general-kernel-api","text":"Once the hello handshake is complete, a sequence of request and responses are exchanged with the @jsii/kernel . Requests take the form of JSON-encoded messages that all follow the following pattern: interface Request { /** * This field discriminates the various request types. */ api : | 'load' // Loading jsii assemblies into the Kernel | 'naming' // Obtaining naming information for loaded assemblies | 'stats' // Obtaining statistics about the Kernel usage | 'create' // Creating objects | 'del' // Destroying objects | 'invoke' | 'sinvoke' // Invoking methods (and static methods) | 'get' | 'sget' // Invoking getters (and static getters) | 'set' | 'sset' // Invoking setters (and static setters) | 'begin' | 'end' ; // Asynchronous method invocation // ... request-type specific fields ... }","title":"General Kernel API"},{"location":"specification/3-kernel-api/#loading-jsii-assemblies-into-the-kernel","text":"Before any jsii type can be used, the assembly that provides it must be loaded into the kernel. Similarly, all dependencies of a given jsii module must have been loaded into the kernel before the module itself can be loaded (the @jsii/kernel does not perform any kind of dependency resolution). Loading new assemblies into the @jsii/kernel is done using the load API: interface LoadRequest { /** The name of the assembly being loaded */ name : string ; /** The version of the assembly being loaded */ version : string ; /** The local path to the npm package for the assembly */ tarball : string ; // The discriminator api : 'load' ; } The response to the load call provides some high-level information pertaining to the loaded assembly, which may be used by the host app to validate the result of the operation: interface LoadResponse { /** The name of the assembly that was just loaded */ assembly : string ; /** The number of types the assembly declared */ types : number ; } Once a module is loaded, all the types it declares immediately become available.","title":"Loading jsii assemblies into the Kernel"},{"location":"specification/3-kernel-api/#obtaining-naming-information-for-loaded-assemblies","text":"In certain cases, host runtime libraries may need to obtain naming information from assemblies in order to determine the translation table from a jsii fully-qualified name to a host -native name. This can be retrieved using the naming call: export interface NamingRequest { /** The name of the assembly for which naming is requested */ assembly : string ; // The discriminator api : 'naming' ; } In response to the naming call, the @jsii/kernel returns the configuration block for each language supported by the named assembly : export interface NamingResponse { /** The naming information for the requested assembly. */ naming : { /** * For each language, provides the jsii configuration block. The content of * this configuration block is specified by each language implementation. */ [ language : string ] : { [ key : string ] : any }; }; }","title":"Obtaining naming information for loaded assemblies"},{"location":"specification/3-kernel-api/#obtaining-statistics-about-the-kernel-usage","text":"The stats call can be used to obtain information about the current Kernel instance, which can be leveraged by unit tests or in order to produce metrics for tracking the health of a long-running jsii app. export interface StatsRequest { // The discriminator api : 'stats' ; } The response to the stats call contains synthetic information about the current state of the Kernel : export interface StatsResponse { /** The number of object reference currently tracked by the Kernel */ objectCount : number ; }","title":"Obtaining statistics about the Kernel usage"},{"location":"specification/3-kernel-api/#creating-objects","text":"Most jsii workflows start with creating instances of objects. This can mean creating a pure JavaScript object, instantiating a sub-class of some JavaScript class, or even creating a pure- host instance that implements a collection of behavioral interfaces . Creating objects is achieved using the create API, which accepts the following parameters: interface CreateRequest { /** The jsii fully qualified name of the class */ fqn : string ; /** Any arguments to provide to the constructor */ args? : any []; /** Additional interfaces implemented in the host app */ interfaces? : string []; /** Any methods or property overridden in the host app */ overrides? : Override []; // The discriminator api : 'create' ; } The response to the object call is a decorated ObjectReference object (which is a common parameter to other calls in the @jsii/kernel API, used to refer to a particular instance): interface ObjectReference { /** A handle that uniquely idenfies an instance */ '$jsii.byref' : string ; } interface CreateResponse extends ObjectReference { /** The list of interfaces implemented by the instance */ '$jsii.interfaces' ? : string []; } The value of the '$jsii.byref' field of the ObjectReference type is formatted in the following way: @aws-cdk/core.Stack@10003 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2514\u2500\u252c\u2500\u2518 \u2502 \u2514\u2500 Opaque numeric identifier \u2514\u2500 Object instance's base class' jsii fully qualified name The first part of the reference identifier can have the special un-qualified value Object to denote the absence of a jsii -known base class (for example when the object only implements a jsii interface).","title":"Creating objects"},{"location":"specification/3-kernel-api/#additional-interfaces","text":"Sometimes, the host app will extend a jsii class and implement new jsii interfaces that were not present on the original type. Such interfaces must be declared by providing their jsii fully qualified name as an entry in the interfaces list. Providing interfaces in this list that are implicitly present from another delcaration (either because they are already implemented by the class denoted by the fqn field, or because another entry in the interfaces list extends it) is valid, but not necessary. The @jsii/kernel is responsible for correctly handling redundant declarations. Danger While declared interfaces may contain redundant declarations of members already declared by other interfaces or by the type denoted by fqn , undefined behavior results if any such declaration is not identical to the others (e.g: property foo declared with type boolean on one of the interfaces , and with type string on another).","title":"Additional Interfaces"},{"location":"specification/3-kernel-api/#overrides","text":"For any method that is implemented or overridden from the host app, the create call must specify an override entry. This will inform the Kernel that calls to these methods must be relayed to the host app for execution, instead of executing the original library's version. An optional cookie string can be provided. This string will be recorded on the Javascript proxying implementation, and will be provided to the host app with any callback request. This information can be used, for example, to improve the performance of implementation lookups in the host app, where the necessary reflection calls would otherwise be prohibitively expensive. Override declarations adhere to the following schema: interface MethodOverride { /** The name of the overridden method */ method : string ; /** An arbitrary override cookie string */ cookie? : string ; } interface PropertyOverride { /** The name of the overridden property */ property : string ; /** An arbitrary override cookie string */ cookie? : string ; } type Override = MethodOverride | PropertyOverride ;","title":"Overrides"},{"location":"specification/3-kernel-api/#a-note-about-callbacks","text":"All @jsii/runtime calls that interact with object instances (that is, any call except for load , naming and stats ; as well as the del call since jsii does not support customized destructors or finalizers) may result in the need to execute code that is defined in the host app, when the code path traverses a method or property that was implemented or overridden in the host app. Such cases will result in a callback request substituting itself to the response of the original call being made; execution of which will resume once the callback response is provided. A callback request is sent from the @jsii/kernel 's node process to the host app and has the following schema: interface CallbackRequest { /** Callback requests are identified by the presence of the `callback` key */ callback : Callback ; } interface CallbackBase { /** A unique identifier for this callback request */ cbid : string ; /** The object on which the callback must be executed */ objref : ObjectReference ; /** The callback cookie, if one was specified */ cookie? : string ; } interface InvokeCallback extends CallbackBase { /** The name of the host method to be invoked */ method : string ; } interface GetCallback extends CallbackBase { /** The name of the property to be read */ property : string ; } interface SetCallback extends CallbackBase { /** The name of the property to be written to */ property : string ; /** The value to be set */ value : any ; } type Callback = InvokeCallback | GetCallback | SetCallback ; In order to fulfill the callback request, the host app may need to perform futher API calls (loading new assemblies, creating new instances, invoking methods - including delegating to the super implementation, ...). Such calls will behave as they otherwise would (including the possible introduction of further callback requests). Once the host app has fulfilled the request, it must signal the result of that execution back to the @jsii/kernel process by using the complete call: interface CompleteBase { /** The callback ID from the corresponding request */ cbid : string ; // The discriminator api : `complete` ; } interface CallbackSuccess extends CompleteBase { /** The result of the execution (`undefined` if void) */ result : any ; } interface CallbackFailure extends CompleteBase { /** The error that was raised during fulfillment */ err : string ; } type CompleteRequest = CallbackSuccess | CallbackFailure ; As discussed earlier, the response to the complete call is the result of resuming execution of the code path that triggered the callback request. This may be another callback request, or the final result of that call. The callbacks call may be used to determine the list of all outstanding callback requests: interface CallbacksRequest { // The discriminator api : 'callbacks' ; } This call results in a list of outstanding callbacks: interface CallbacksResponse { /** The list of outstanding callback requests */ callbacks : Callback []; }","title":"A note about callbacks"},{"location":"specification/3-kernel-api/#destroying-objects","text":"Once the host app no longer needs a particular object, it can be discarded. This can happen for example when the host reference to an object is garbage collected or freed. In order to allow the JavaScript process to also reclaim the associated memory footprint, the del API must be used: interface DelRequest { /** The object reference that can be released */ objref : ObjectReference ; // The discriminator api : 'del' ; } Danger Failure to use the del API will result in memory leakage as the JavaScript process accumulates garbage in its Kernel instance. This can eventually result in a Javascript heap out of memory error, and the abnormal termination of the node process, and consequently of the host app. Unimplemented The existing host runtime libraries do not implement this behavior! Question There is currently no provision for the node process to inform the host app about object references it dropped. This mechanism is necessary in order to support garbage collection of resources that involve host -implemented code (in such cases, the host app must hold on to any instance it passed to JavaScript until it is no longer reachable from there). Upon successfully deleting an object reference, the @jsii/kernel will return an empty response object: export interface DelResponse {}","title":"Destroying Objects"},{"location":"specification/3-kernel-api/#invoking-methods-and-static-methods","text":"Invoking methods is done via the invoke call: interface InvokeRequest { /** The object reference on which a method is invoked */ objref : ObjectReference ; /** The name of the method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'invoke' ; } Static method invocations do not have a receiving instance, and instead are implemented by way of the sinvoke call: interface StaticInvokeRequest { /** The jsii fully qualified name of the declaring type */ fqn : string ; /** The name of the static method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'sinvoke' ; } Note that, unlike in certain programming languages such as Java , it is illegal to attempt invoking a static method on the static type of some instance using the invoke call. All static invocations must be done using sinvoke . Both the invoke and sinvoke calls result in the same response: interface InvokeResponse { /** The result of the method invocation. */ result : any ; } When the method's return type is void , the result value should typically be undefined , however it may not be ?? ( TypeScript may in certain circumstances allow returning a value from a void method): the host app should ignore such values.","title":"Invoking methods (and static methods)"},{"location":"specification/3-kernel-api/#asynchronous-method-invocation","text":"The invoke call can only be used to invoke synchronous methods. In order to invoke asynchronous methods, the begin and end calls must be used instead. Once the host app has entered an asynchronous workflow (after it makes the first begin call), and until it has completed all asynchronous operations (after all begin class are matched with an end call), no synchronous operation (including synchronous callbacks) may be initiated. interface BeginRequest { /** The object reference on which an asynchronous method is invoked */ objref : ObjectReference ; /** The name of the method being invoked */ method : string ; /** Any arguments passed to the method invocation */ args? : any []; // The discriminator api : 'begin' ; } Question There is no static form of this call. Should there be one? The begin call results in a promise being made: interface BeginResponse { /** * An opaque string that uniquely idenfies the promised result of this * invocation. */ promiseid : string ; } Whenever the host app needs to obtain the promised value (possibly in a blocking way), it makes the corresponding end call: interface EndRequest { /** The promiseid that was returned from the corresponding `begin` call. */ promiseid : string ; // The discriminator api : 'end' ; } This will result in the promise being awaited and then resolved: interface EndResponse { /** The resolved value of the promise */ result : any ; } Danger All begin calls must be matched with an end call. Failure to do so may result in unhandled promise rejections that might cause the application to terminate in certain environments.","title":"Asynchronous method invocation"},{"location":"specification/3-kernel-api/#invoking-getters-and-static-getters","text":"In order to obtain the value of properties, the get call is used: interface GetRequest { /** The object reference on which a poperty is read */ objref : ObjectReference ; /** The name of the property being read */ property : string ; // The discriminator api : 'get' ; } When operating on static properties, or in order to obtain the value of enum constants, the sget API must be used instead: interface StaticGetRequest { /** The jsii fully qualified name of the declaring type */ fqn : ObjectReference ; /** The name of the property being read */ property : string ; // The discriminator api : 'sget' ; } Both the get and sget calls result in the same response: interface GetResponse { /** The value of the property. */ result : any ; }","title":"Invoking getters (and static getters)"},{"location":"specification/3-kernel-api/#invoking-setters-and-static-setters","text":"In order to change the value of a property, the set call is used: interface SetRequest { /** The object reference on which a poperty is written to */ objref : ObjectReference ; /** The name of the property being written to */ property : string ; /** The value that is written to the property */ value : any ; // The discriminator api : 'set' ; } When operating on static properties, the sset API must be used instead: interface StaticSetRequest { /** The jsii fully qualified name of the declaring type */ fqn : ObjectReference ; /** The name of the property being written to */ property : string ; /** The value that is written to the property */ value : any ; // The discriminator api : 'sset' ; } Both the set and sset calls result in the same response, which is an empty object: interface SetResponse {}","title":"Invoking setters (and static setters)"},{"location":"specification/4-standard-compliance-suite/","text":"Standard Compliance Suite Goal The goal of the standard compliance suite is to be a normative description of the behaviors that all language runtime implementations ( host runtime library in combination with code generation ) must implement. This description takes the form of a collection of test cases that must be re-implemented in each host language, so that compliance can be asserted. Since the goal of jsii is to expose a single Object-Oriented API to multiple programming languages, it is important to ensure the behavior is consistent across all of them. This can be achieved by making sure that the interactions between the host and kernel processes are the same for a given use-case. Format In order to assert whether a new runtime implementation is correct, a formal compliance test suite is defined, that all language runtimes must fully implement before they can be deemed eligible for General Availability. This document describes these tests, as well as a general approach for ensuring conformance requirements are met in a systematic manner. Categories Test cases in the standard compliance suite are grouped by categories, which help implementors direct their effort in the early stages of the implementation of new language bindings. Each category is declared in an H3 title (a line that starts with ### ) within the [ ## Test Suite ] title. A description of the category immediately follows the opening title. The category ends with the end of the document, or whenever another H2 title is reached. Test Case Within a category title, test cases are delimited by H4 ( #### ) titles, which correspond to the test case name. The test case name should be kept concise (ideally within 75 characters) and try to be as descriptive as possible. Immediately after the H4 title is an English language description of the test case that explains the property the test is designed to validate in as much detail as possible. As much as possible, test case descriptions should be self-sufficient. After the attributes table, a TypeScript block of code describes the canonical form of the test. It includes any type declaration that is used by the test (so the code example is self-contained). Assertions performed by the test should be written in the form of [ jest ] expectations. Question The assertion code is intended as a formal representation of the tests' normative procedure. It is not currently executed against the kernel , but this could be achieved in the future. Additionally, we might be able to automatically transliterate the tests to other languages using [ jsii-rosetta ]. Finally, another code block details the sequence of messages that should be exchanged between the host and node processes during the execution of the test case, such that implementations can assert coherent behavior. Initial messages corresponding to the hello and load calls can be omitted at the beginning of the kernel trace. Those messages are typically identical across tests and there is little value in asserting around those. However, any load call happening after the first call that is neither the hello message or another load call must be included. The dialogue is the sequence of JSON formatted messages, from the perspective of the host app, using the following notation: Messages sent by the host runtime to the node process: > { \"api\": \"foo\" } Messages received by the host runtime from the node process: < { \"result\": \"bar\" } Comments to improve readability of the trace: # Comment continues until the end of the line Blank lines can be added to logically group trace elements Question Is there a need to support some form of a capture mechanism to provision for non-deterministic results, or non-normative elements such as the exact Object IDs issued for created instances? Show Template Below is the template markdown to copy-paste when introducing a new test case in the compliance suite. New tests should always be added at the very end of the category they belong to, right after the last test in said category. ### Test Category #### Test Case Name A short english language description of what property this test verifies. The description should include enough detail for a reader to be able to understand the test without having to search for any additional information. Prefer a long, unambiguous description to a terse one that could be subject to interpretation. <details><summary>Show test</summary> ##### Reference Implementation ```ts // GIVEN export class Foo { /* ... */ } // WHEN const bar = new Foo (). bar (); // THEN expect ( bar . baz ). toBeUndefined (); ``` ##### Reference Kernel Messaging ``` ## You can omit the initial hello/load messages # < { \"hello\": \"@jsii/runtime@1.2.3\" } # > { \"load\": { \"name\": \"test-case-001\", \"version\": \"1.2.3\", \"tarball\": \"/tmp/jsii-kernel-test/lib.tgz\" } } # < { \"assembly\": \"test-case-001\", \"types\": 3 } ``` </details> Compliance In order to be able to assert compliance of language binding libraries to the standard test suite, implementations are responsible for providing a test harness (typically as part of the runtime library) that can produce a standardized test report in the form of a JSON document that follows the following schema: interface TestReport { /** The report is broken down by test category, using the name as-is */ [ category : string ] : { /** For each test in the category, using its name as-is */ [ test : string ] : { /** Whether the test passed or failed */ status : 'PASS' | 'FAIL' ; /** The kernel messages captured during the test */ kernelTrace : Array < KernelMessage > ; }; }; } interface KernelMessage { /** The direction the message was sent (Host -> Kernel / Kernel -> Host) */ direction : 'FromKernel' | 'ToKernel' ; /** The message, as a JSON object */ message : { [ key : string ] : unknown }; } The @jsii/compliance package provides the necessary tools to consume such a test report, together with the Markdown document describing the compliance suite, and procuces a report describing compliance test coverage as well as information about any non-conformant test result. Unimplemented The @jsii/compliance tool does not exist yet. Question Should a \"somewhat standard\" format such as XUnit test report be used instead of rolling our own JSON document? Test Suite Legacy This section is due to contain all compliance tests that were implemented before the jsii specification was initially written. They are going to be gradually replaced by more focused tests with better descriptions. Type Unions are correctly disambiguated by the Kernel In certain cases, two or more types in a Type Union can overlap in such a way that they are all valid structural types for the value. Statically typed languages however will not be satisfied with structural typing only, and require the correct declared type to be preserved. Show test Reference Implementation // GIVEN export interface BluePill { readonly offeredTo : string ; readonly makesYouForgetTheMatrix? : boolean ; } export interface RedPill { readonly offeredTo : string ; readonly makesYouExitTheMatrix? : boolean ; } export class Morpheus { public static isBlue ( pill : BluePill | RedPill ) : pill is BluePill { const keys = new Set ( Object . keys ( pill )); switch ( keys . size ) { case 1 : return keys . has ( 'offeredTo' ); case 2 : return keys . has ( 'offeredTo' ) && keys . has ( 'makesYouForgetTheMatrix' ); default : return false ; } } public static isRed ( pill : BluePill | RedPill ) : pill is RedPill { const keys = new Set ( Object . keys ( pill )); switch ( keys . size ) { case 1 : return keys . has ( 'offeredTo' ); case 2 : return keys . has ( 'offeredTo' ) && keys . has ( 'makesYouExitTheMatrix' ); default : return false ; } } private constructor () {} } export class Neo { public readonly tookBlue : boolean ; public readonly tookRed : boolean ; public constructor ( public readonly pill : BluePill | RedPill ) { this . tookBlue = pill . offeredTo == 'Neo' && Morpheus . isBlue ( pill ); this . tookRed = pill . offeredTo == 'Neo' && Morpheus . isRed ( pill ); } } // WHEN const bluePillA = new Neo ({ offeredTo : 'not Neo' }); const bluePillB = new Neo ({ offeredTo : 'Neo' , makesYouForgetTheMatrix : true }); const redPillA = new Neo ({ offeredTo : 'not Neo' }); const redPillB = new Neo ({ offeredTo : 'Neo' , makesYouExitTheMatrix : true }); // THEN expect ( bluePillA . pill instanceof BluePill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( bluePillB . pill instanceof BluePill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeTruthy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( redPillA . pill instanceof RedPill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( redPillB . pill instanceof RedPill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeTruthy (); Kernel Trace Partially initialized object consumption When a constructor passes this out from JavaScript to the host app, the reference must be correctly identified and passed across. Unimplemented The .NET Runtime does not currently honor object identity, meaning that despite the same object reference is returned twice, two distinct proxies exist for it in the host .NET app. Generally speaking, using pure object identity on jsii language front-ends is dangerous, as certain statically typed language will require the runtime to have different instances for different static types a given object reference is surfaced as. It may be necessary to introduce a helper akin to Jsii.isSameObject(a, b) to enable identity predicates to be used. Other helper functions may be necessary, too, such as one to obtain a \"consistent\" object hash for instances in Java (so they can be safely used with HashMap , ...). Show test Reference Implementation // GIVEN export abstract class PartiallyInitializedThisConsumer { public abstract consumePartiallyInitializedThis ( obj : ConstructorPassesThisOut ) : void ; } export class ConstructorPassesThisOut { public constructor ( consumer : PartiallyInitializedThisConsumer ) { consumer . consumePartiallyInitializedThis ( this ); } } // WHEN class MyConsumer extends PartiallyInitializedThisConsumer { public obj? : ConstructorPassesThisOut = null ; public consumePartiallyInitializedThis ( obj : ConstructorPassesThisOut ) { this . obj = obj ; } } const consumer = new MyConsumer (); const object = new ConstructorPassesThisOut ( consumer ); // THEN expect ( consumer . obj ). toBe ( object ); Kernel Trace # < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"test.PartiallyInitializedThisConsumer\",\"args\":[],\"overrides\":[{\"method\":\"consumePartiallyInitializedThis\"}],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"}} > {\"api\":\"create\",\"fqn\":\"test.ConstructorPassesThisOut\",\"args\":[{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]} < {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"},\"method\":\"consumePartiallyInitializedThis\",\"args\":[{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}]}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\"}} < {\"ok\":{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}} Interfaces Tests in this section ensure correct behavior of behavioral interfaces . Host app can implement an interface \"from scratch\" It is possible for a \"pure\" host interface implementation to be passed across the language boundary, it's methods and properties can be used by JavaScript code within the Kernel process. Bug The .NET Runtime currently requires that pure interfaces implementations extend from Amazon.JSII.Rutime.Deputy.DepytyBase . Bug The Python Runtime currently expects a somewhat un-pythonic way to implement interfaces, which requires decorating the implementing class with @jsii.implements(\"implemented-type.JsiiInterfaceFQN\") . Show test Reference Implementation // GIVEN export interface IBehavioralInterface { methodCall () : string ; readonly property : number ; } export class InterfaceConsumer { constructor ( private readonly iface : IBehavioralInterface ) {} public composeResult () { return ` ${ this . iface . methodCall () } / ${ this . iface . property } ` ; } } // WHEN class Implementation implements IBehavioralInterface { public readonly property = 1337 ; public methodCall () { return 'Hello!' ; } } const impl = new Implementation (); const consumer = new InterfaceConsumer ( impl ); // THEN expect ( consumer . composeResult ()). toBe ( 'Hello! / 1337' ); Kernel Trace # < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"Object\",\"args\":[],\"overrides\":[{\"method\":\"methodCall\"},{\"property\":\"property\"}],\"interfaces\":[\"test.IBehavioralInterface\"]} < {\"ok\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]}} > {\"api\":\"create\",\"fqn\":\"test.InterfaceConsumer\",\"args\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"}} > {\"api\":\"invoke\",\"objref\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"},\"method\":\"composeResult\",\"args\":[]} < {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"method\":\"methodCall\",\"args\":[]}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\",\"result\":\"Hello!\"}} < {\"callback\":{\"cbid\":\"jsii::callback::20001\",\"get\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"property\":\"property\"}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20001\",\"result\":1337.0}} < {\"ok\":{\"result\":\"Hello! / 1337\"}} Structs & Keyword Arguments Ambiguous arguments are handled correctly When a method accepts both a positional parameter named foo and a struct parameter with a property named foo , the respective values are passed in the correct parameter location when calling into the JavaScript code. Show test Reference Implementation // GIVEN export interface StructType { readonly foo : string ; } export class ClassType { public constructor ( public readonly foo : number , public readonly opts : StructType ) {} } // WHEN var result = new ClassType ( 'Bazinga!' , { foo : 1337 }); // THEN expect ( typeof result . foo ). toBe ( 1337 ); expect ( typeof result . opts . foo ). toBe ( 'Bazinga!' ); Kernel Trace # < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"test.ClassType\",\"args\":[1337.0,{\"$jsii.struct\":{\"fqn\":\"test.StructType\",\"data\":{\"foo\":\"Bazinga!\"}}}],\"overrides\":[],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.ClassType@10000\"}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"foo\"} < {\"ok\":{\"value\":1337}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"opts\"} < {\"ok\":{\"value\":{\"$jsii.byref\":\"Object@10001\",\"$jsii.interfaces\":[\"test.StructType\"]}}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"Object@10001\"},\"property\":\"foo\"} < {\"ok\":{\"value\":\"Bazinga!\"}} Collections Tests in this section ensure correct behavior of collections ( List and Map ). Struct elements of List are deserialized to the correct apparent type When the declared element type of a List is a struct , the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified. Show test Reference Implementation // GIVEN export interface StructType { readonly property : string ; } export class StructProvider { public static provide () : StructType [] { return [{ property : 'value' }]; } } // WHEN const items = StructProvider . provide (); // THEN expect ( items . length ). toBeGreaterThan ( 0 ); for ( const item of items ) { expect ( item instanceof StructType ). toBeTruthy (); } Kernel Trace # < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]} < {\"ok\":{\"result\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}]}} Struct elements of Map are deserialized to the correct apparent type When the declared element type of a Map is a struct , the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified. Show test Reference Implementation // GIVEN export interface StructType { readonly property : string ; } export class StructProvider { public static provide () : { [ key : string ] : StructType } { return { foo : { property : 'value' } }; } } // WHEN const items = StructProvider . provide (); // THEN expect ( items . length ). toBeGreaterThan ( 0 ); for ( const item of Object . values ( items )) { expect ( item instanceof StructType ). toBeTruthy (); } Kernel Trace # < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]} < {\"ok\":{\"result\":{\"$jsii.map\":{\"foo\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}}}}}","title":"Standard Compliance Suite"},{"location":"specification/4-standard-compliance-suite/#standard-compliance-suite","text":"","title":"Standard Compliance Suite"},{"location":"specification/4-standard-compliance-suite/#goal","text":"The goal of the standard compliance suite is to be a normative description of the behaviors that all language runtime implementations ( host runtime library in combination with code generation ) must implement. This description takes the form of a collection of test cases that must be re-implemented in each host language, so that compliance can be asserted. Since the goal of jsii is to expose a single Object-Oriented API to multiple programming languages, it is important to ensure the behavior is consistent across all of them. This can be achieved by making sure that the interactions between the host and kernel processes are the same for a given use-case.","title":"Goal"},{"location":"specification/4-standard-compliance-suite/#format","text":"In order to assert whether a new runtime implementation is correct, a formal compliance test suite is defined, that all language runtimes must fully implement before they can be deemed eligible for General Availability. This document describes these tests, as well as a general approach for ensuring conformance requirements are met in a systematic manner.","title":"Format"},{"location":"specification/4-standard-compliance-suite/#categories","text":"Test cases in the standard compliance suite are grouped by categories, which help implementors direct their effort in the early stages of the implementation of new language bindings. Each category is declared in an H3 title (a line that starts with ### ) within the [ ## Test Suite ] title. A description of the category immediately follows the opening title. The category ends with the end of the document, or whenever another H2 title is reached.","title":"Categories"},{"location":"specification/4-standard-compliance-suite/#test-case","text":"Within a category title, test cases are delimited by H4 ( #### ) titles, which correspond to the test case name. The test case name should be kept concise (ideally within 75 characters) and try to be as descriptive as possible. Immediately after the H4 title is an English language description of the test case that explains the property the test is designed to validate in as much detail as possible. As much as possible, test case descriptions should be self-sufficient. After the attributes table, a TypeScript block of code describes the canonical form of the test. It includes any type declaration that is used by the test (so the code example is self-contained). Assertions performed by the test should be written in the form of [ jest ] expectations. Question The assertion code is intended as a formal representation of the tests' normative procedure. It is not currently executed against the kernel , but this could be achieved in the future. Additionally, we might be able to automatically transliterate the tests to other languages using [ jsii-rosetta ]. Finally, another code block details the sequence of messages that should be exchanged between the host and node processes during the execution of the test case, such that implementations can assert coherent behavior. Initial messages corresponding to the hello and load calls can be omitted at the beginning of the kernel trace. Those messages are typically identical across tests and there is little value in asserting around those. However, any load call happening after the first call that is neither the hello message or another load call must be included. The dialogue is the sequence of JSON formatted messages, from the perspective of the host app, using the following notation: Messages sent by the host runtime to the node process: > { \"api\": \"foo\" } Messages received by the host runtime from the node process: < { \"result\": \"bar\" } Comments to improve readability of the trace: # Comment continues until the end of the line Blank lines can be added to logically group trace elements Question Is there a need to support some form of a capture mechanism to provision for non-deterministic results, or non-normative elements such as the exact Object IDs issued for created instances? Show Template Below is the template markdown to copy-paste when introducing a new test case in the compliance suite. New tests should always be added at the very end of the category they belong to, right after the last test in said category. ### Test Category #### Test Case Name A short english language description of what property this test verifies. The description should include enough detail for a reader to be able to understand the test without having to search for any additional information. Prefer a long, unambiguous description to a terse one that could be subject to interpretation. <details><summary>Show test</summary> ##### Reference Implementation ```ts // GIVEN export class Foo { /* ... */ } // WHEN const bar = new Foo (). bar (); // THEN expect ( bar . baz ). toBeUndefined (); ``` ##### Reference Kernel Messaging ``` ## You can omit the initial hello/load messages # < { \"hello\": \"@jsii/runtime@1.2.3\" } # > { \"load\": { \"name\": \"test-case-001\", \"version\": \"1.2.3\", \"tarball\": \"/tmp/jsii-kernel-test/lib.tgz\" } } # < { \"assembly\": \"test-case-001\", \"types\": 3 } ``` </details>","title":"Test Case"},{"location":"specification/4-standard-compliance-suite/#compliance","text":"In order to be able to assert compliance of language binding libraries to the standard test suite, implementations are responsible for providing a test harness (typically as part of the runtime library) that can produce a standardized test report in the form of a JSON document that follows the following schema: interface TestReport { /** The report is broken down by test category, using the name as-is */ [ category : string ] : { /** For each test in the category, using its name as-is */ [ test : string ] : { /** Whether the test passed or failed */ status : 'PASS' | 'FAIL' ; /** The kernel messages captured during the test */ kernelTrace : Array < KernelMessage > ; }; }; } interface KernelMessage { /** The direction the message was sent (Host -> Kernel / Kernel -> Host) */ direction : 'FromKernel' | 'ToKernel' ; /** The message, as a JSON object */ message : { [ key : string ] : unknown }; } The @jsii/compliance package provides the necessary tools to consume such a test report, together with the Markdown document describing the compliance suite, and procuces a report describing compliance test coverage as well as information about any non-conformant test result. Unimplemented The @jsii/compliance tool does not exist yet. Question Should a \"somewhat standard\" format such as XUnit test report be used instead of rolling our own JSON document?","title":"Compliance"},{"location":"specification/4-standard-compliance-suite/#test-suite","text":"","title":"Test Suite"},{"location":"specification/4-standard-compliance-suite/#legacy","text":"This section is due to contain all compliance tests that were implemented before the jsii specification was initially written. They are going to be gradually replaced by more focused tests with better descriptions.","title":"Legacy"},{"location":"specification/4-standard-compliance-suite/#type-unions-are-correctly-disambiguated-by-the-kernel","text":"In certain cases, two or more types in a Type Union can overlap in such a way that they are all valid structural types for the value. Statically typed languages however will not be satisfied with structural typing only, and require the correct declared type to be preserved. Show test","title":"Type Unions are correctly disambiguated by the Kernel"},{"location":"specification/4-standard-compliance-suite/#reference-implementation","text":"// GIVEN export interface BluePill { readonly offeredTo : string ; readonly makesYouForgetTheMatrix? : boolean ; } export interface RedPill { readonly offeredTo : string ; readonly makesYouExitTheMatrix? : boolean ; } export class Morpheus { public static isBlue ( pill : BluePill | RedPill ) : pill is BluePill { const keys = new Set ( Object . keys ( pill )); switch ( keys . size ) { case 1 : return keys . has ( 'offeredTo' ); case 2 : return keys . has ( 'offeredTo' ) && keys . has ( 'makesYouForgetTheMatrix' ); default : return false ; } } public static isRed ( pill : BluePill | RedPill ) : pill is RedPill { const keys = new Set ( Object . keys ( pill )); switch ( keys . size ) { case 1 : return keys . has ( 'offeredTo' ); case 2 : return keys . has ( 'offeredTo' ) && keys . has ( 'makesYouExitTheMatrix' ); default : return false ; } } private constructor () {} } export class Neo { public readonly tookBlue : boolean ; public readonly tookRed : boolean ; public constructor ( public readonly pill : BluePill | RedPill ) { this . tookBlue = pill . offeredTo == 'Neo' && Morpheus . isBlue ( pill ); this . tookRed = pill . offeredTo == 'Neo' && Morpheus . isRed ( pill ); } } // WHEN const bluePillA = new Neo ({ offeredTo : 'not Neo' }); const bluePillB = new Neo ({ offeredTo : 'Neo' , makesYouForgetTheMatrix : true }); const redPillA = new Neo ({ offeredTo : 'not Neo' }); const redPillB = new Neo ({ offeredTo : 'Neo' , makesYouExitTheMatrix : true }); // THEN expect ( bluePillA . pill instanceof BluePill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( bluePillB . pill instanceof BluePill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeTruthy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( redPillA . pill instanceof RedPill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeFalsy (); expect ( redPillB . pill instanceof RedPill ). toBeTruthy (); expect ( bluePillA . tookBlue ). toBeFalsy (); expect ( bluePillA . tookRed ). toBeTruthy ();","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace","text":"","title":"Kernel Trace"},{"location":"specification/4-standard-compliance-suite/#partially-initialized-object-consumption","text":"When a constructor passes this out from JavaScript to the host app, the reference must be correctly identified and passed across. Unimplemented The .NET Runtime does not currently honor object identity, meaning that despite the same object reference is returned twice, two distinct proxies exist for it in the host .NET app. Generally speaking, using pure object identity on jsii language front-ends is dangerous, as certain statically typed language will require the runtime to have different instances for different static types a given object reference is surfaced as. It may be necessary to introduce a helper akin to Jsii.isSameObject(a, b) to enable identity predicates to be used. Other helper functions may be necessary, too, such as one to obtain a \"consistent\" object hash for instances in Java (so they can be safely used with HashMap , ...). Show test","title":"Partially initialized object consumption"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_1","text":"// GIVEN export abstract class PartiallyInitializedThisConsumer { public abstract consumePartiallyInitializedThis ( obj : ConstructorPassesThisOut ) : void ; } export class ConstructorPassesThisOut { public constructor ( consumer : PartiallyInitializedThisConsumer ) { consumer . consumePartiallyInitializedThis ( this ); } } // WHEN class MyConsumer extends PartiallyInitializedThisConsumer { public obj? : ConstructorPassesThisOut = null ; public consumePartiallyInitializedThis ( obj : ConstructorPassesThisOut ) { this . obj = obj ; } } const consumer = new MyConsumer (); const object = new ConstructorPassesThisOut ( consumer ); // THEN expect ( consumer . obj ). toBe ( object );","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_1","text":"# < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"test.PartiallyInitializedThisConsumer\",\"args\":[],\"overrides\":[{\"method\":\"consumePartiallyInitializedThis\"}],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"}} > {\"api\":\"create\",\"fqn\":\"test.ConstructorPassesThisOut\",\"args\":[{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]} < {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"test.PartiallyInitializedThisConsumer@10000\"},\"method\":\"consumePartiallyInitializedThis\",\"args\":[{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}]}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\"}} < {\"ok\":{\"$jsii.byref\":\"test.ConstructorPassesThisOut@10001\"}}","title":"Kernel Trace"},{"location":"specification/4-standard-compliance-suite/#interfaces","text":"Tests in this section ensure correct behavior of behavioral interfaces .","title":"Interfaces"},{"location":"specification/4-standard-compliance-suite/#host-app-can-implement-an-interface-from-scratch","text":"It is possible for a \"pure\" host interface implementation to be passed across the language boundary, it's methods and properties can be used by JavaScript code within the Kernel process. Bug The .NET Runtime currently requires that pure interfaces implementations extend from Amazon.JSII.Rutime.Deputy.DepytyBase . Bug The Python Runtime currently expects a somewhat un-pythonic way to implement interfaces, which requires decorating the implementing class with @jsii.implements(\"implemented-type.JsiiInterfaceFQN\") . Show test","title":"Host app can implement an interface \"from scratch\""},{"location":"specification/4-standard-compliance-suite/#reference-implementation_2","text":"// GIVEN export interface IBehavioralInterface { methodCall () : string ; readonly property : number ; } export class InterfaceConsumer { constructor ( private readonly iface : IBehavioralInterface ) {} public composeResult () { return ` ${ this . iface . methodCall () } / ${ this . iface . property } ` ; } } // WHEN class Implementation implements IBehavioralInterface { public readonly property = 1337 ; public methodCall () { return 'Hello!' ; } } const impl = new Implementation (); const consumer = new InterfaceConsumer ( impl ); // THEN expect ( consumer . composeResult ()). toBe ( 'Hello! / 1337' );","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_2","text":"# < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"Object\",\"args\":[],\"overrides\":[{\"method\":\"methodCall\"},{\"property\":\"property\"}],\"interfaces\":[\"test.IBehavioralInterface\"]} < {\"ok\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]}} > {\"api\":\"create\",\"fqn\":\"test.InterfaceConsumer\",\"args\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[]}],\"overrides\":[],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"}} > {\"api\":\"invoke\",\"objref\":{\"$jsii.byref\":\"test.InterfaceConsumer@10001\"},\"method\":\"composeResult\",\"args\":[]} < {\"callback\":{\"cbid\":\"jsii::callback::20000\",\"invoke\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"method\":\"methodCall\",\"args\":[]}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20000\",\"result\":\"Hello!\"}} < {\"callback\":{\"cbid\":\"jsii::callback::20001\",\"get\":{\"objref\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.IBehavioralInterface\"]},\"property\":\"property\"}}} > {\"complete\":{\"api\":\"complete\",\"cbid\":\"jsii::callback::20001\",\"result\":1337.0}} < {\"ok\":{\"result\":\"Hello! / 1337\"}}","title":"Kernel Trace"},{"location":"specification/4-standard-compliance-suite/#structs-keyword-arguments","text":"","title":"Structs &amp; Keyword Arguments"},{"location":"specification/4-standard-compliance-suite/#ambiguous-arguments-are-handled-correctly","text":"When a method accepts both a positional parameter named foo and a struct parameter with a property named foo , the respective values are passed in the correct parameter location when calling into the JavaScript code. Show test","title":"Ambiguous arguments are handled correctly"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_3","text":"// GIVEN export interface StructType { readonly foo : string ; } export class ClassType { public constructor ( public readonly foo : number , public readonly opts : StructType ) {} } // WHEN var result = new ClassType ( 'Bazinga!' , { foo : 1337 }); // THEN expect ( typeof result . foo ). toBe ( 1337 ); expect ( typeof result . opts . foo ). toBe ( 'Bazinga!' );","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_3","text":"# < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"create\",\"fqn\":\"test.ClassType\",\"args\":[1337.0,{\"$jsii.struct\":{\"fqn\":\"test.StructType\",\"data\":{\"foo\":\"Bazinga!\"}}}],\"overrides\":[],\"interfaces\":[]} < {\"ok\":{\"$jsii.byref\":\"test.ClassType@10000\"}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"foo\"} < {\"ok\":{\"value\":1337}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"test.ClassType@10000\"},\"property\":\"opts\"} < {\"ok\":{\"value\":{\"$jsii.byref\":\"Object@10001\",\"$jsii.interfaces\":[\"test.StructType\"]}}} > {\"api\":\"get\",\"objref\":{\"$jsii.byref\":\"Object@10001\"},\"property\":\"foo\"} < {\"ok\":{\"value\":\"Bazinga!\"}}","title":"Kernel Trace"},{"location":"specification/4-standard-compliance-suite/#collections","text":"Tests in this section ensure correct behavior of collections ( List and Map ).","title":"Collections"},{"location":"specification/4-standard-compliance-suite/#struct-elements-of-list-are-deserialized-to-the-correct-apparent-type","text":"When the declared element type of a List is a struct , the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified. Show test","title":"Struct elements of List are deserialized to the correct apparent type"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_4","text":"// GIVEN export interface StructType { readonly property : string ; } export class StructProvider { public static provide () : StructType [] { return [{ property : 'value' }]; } } // WHEN const items = StructProvider . provide (); // THEN expect ( items . length ). toBeGreaterThan ( 0 ); for ( const item of items ) { expect ( item instanceof StructType ). toBeTruthy (); }","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_4","text":"# < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]} < {\"ok\":{\"result\":[{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}]}}","title":"Kernel Trace"},{"location":"specification/4-standard-compliance-suite/#struct-elements-of-map-are-deserialized-to-the-correct-apparent-type","text":"When the declared element type of a Map is a struct , the resulting list must contain elements of the correct static type. This is a requirement for statically typed languages such as Java where type parameters are reified. Show test","title":"Struct elements of Map are deserialized to the correct apparent type"},{"location":"specification/4-standard-compliance-suite/#reference-implementation_5","text":"// GIVEN export interface StructType { readonly property : string ; } export class StructProvider { public static provide () : { [ key : string ] : StructType } { return { foo : { property : 'value' } }; } } // WHEN const items = StructProvider . provide (); // THEN expect ( items . length ). toBeGreaterThan ( 0 ); for ( const item of Object . values ( items )) { expect ( item instanceof StructType ). toBeTruthy (); }","title":"Reference Implementation"},{"location":"specification/4-standard-compliance-suite/#kernel-trace_5","text":"# < {\"hello\":\"@jsii/runtime@...\"} # > {\"api\":\"load\",\"name\":\"...\",\"version\":\"...\",\"tarball\":\"...\"} # < {\"ok\":{\"assembly\":\"...\",\"types\":2}} > {\"api\":\"sinvoke\",\"fqn\":\"test.StructProvider\",\"method\":\"provide\",\"args\":[]} < {\"ok\":{\"result\":{\"$jsii.map\":{\"foo\":{\"$jsii.byref\":\"Object@10000\",\"$jsii.interfaces\":[\"test.StructType\"]}}}}}","title":"Kernel Trace"},{"location":"specification/5-new-language-intake/","text":"New Language Intake This document outlines the process to be followed when introducing a new jsii target language, including an estimated timeline (the exact timeline may vary significantly depending on the specifics of the language being added). The estimated total duration for the process is 4 to 6 months. Planning Estimated Duration: 2 weeks The first step is to study the jsii specification, as well as existing language implementations, in order to have the knowledge necessary to write a new language support proposal RFC . The RFC document produced will evolve and be polished as development of the new language support progresses, but the following elements must be present before any implementation begins: Identification of the language's standard package repository Proposal for the binding's configuration block Sample API representations in the proposed language In particular, any element from the jsii type model that does not naturally map into the proposed new language needs to be represented Where several options exist, links to prior art are instrumental to validate the direction chosen Toolchain and platform requirements Code Generation ( jsii-pacmak ) Estimated Duration: 4 to 6 weeks The necessary code must be added to [ jsii-pacmak ] in order to map the jsii assembly's declared types into the proposed language. While this code ought to leverage the new language's host runtime library, we begin with writing the code generator in order to ensure the appropriate developer experience is achieved in the new language before writing the back-end components. Code generators are authored in TypeScript . The necessary reserved words need to be registered in the jsii compiler, so that warnings are produced when identifiers are used in TypeScript code that require slugification or escaping in the target language (and will hence cause a degraded developer experience). Runtime Library Estimated Duration: 4 to 6 weeks Now that the appropriate developer experience has been identified, the host runtime library supporting the generated code can be written. This component must be written in the new language. Unimplemented A reference architecture for host runtime libraries is to be developed, in order to ensure consistent naming and behavior across all the runtimes, reducing the cost of maintaining many of those. Building & Packaging Estimated Duration: 2 weeks Once code is generated and it has a host runtime library to rely on, [ jsii-pacmak ] needs to receive the additional logic required to compile and package the generated libraries as required, producing ready-to-publish artifacts. The necessary toolchain needs to be added to the [ jsii/superchain ] Docker image, so that jsii customers can rely on this to build artifacts for any of the supported languages. In addition to this, standardized Amazon CodePipeline actions need to be developed in order to support publishing to the relevant idiomatic package managers. Compliance Tests Estimated Duration: 6 weeks The full standard compliance suite must be implemented for the new language. Leveraging the new code generator, host runtime library and compilation logic, the tests demonstrate that the new library behaves consistently with all other language bindings. While it is possible to declare developer preview on a new language before all the tests pass, full compliance is a pre-requisite to declaring general availability of the new language. Documentation Estimated Duration: 1 week The necessary documentation needs to be provided to support customers who want to onboard the new language. This also includes updating [ jsii-config ] with support for the new languages' configuration block. Developer Preview Recommended Duration: 4 to 8 weeks It is possible to declare Developer Preview for a new language support as soon as the code generation and host runtime library are mature enough to be useful, and cover the majority of use-cases. While certain edge-cases may still be uncovered at the beginning of Developer Preview , a clear plan should exist that ensures a path exists to address any known gaps. It is required to have implemented most of the standard compliance suite prior to declaring Developer Preview . During the Developer Preview phase, user experience studies should be conducted to validate assumptions made during the code generator's design. If any significant change is dictated by the results of the user experience studies, fluback studies should be performed in order to confirm that the desired impact has been achieved. Unimplemented A standard set of user experience study tasks will be developed, ensuring the learnings from previous experiences is factored into subsequent studies conducted. Finally, it is essential to give time to the community to use and vet the new language support prior to considering General Availability . A minimum of a full month without a major bug reported is advised. During this period, intentional hands-on usage of the product msut be performed by engineers familiar with the new language as well as engineers unfamilar with it. This ensures the new experience is considered holistically, in a manner unbiased by knowledge of the implementation. General Availability Once the new language support has been Developer Preview for long enough and the engineers involved have gained confidence that the API is stable, covers all known use-cases reliably, and behaves consistently with other Generally Available languages, the new support can be considered for General Availability .","title":"New Language Intake"},{"location":"specification/5-new-language-intake/#new-language-intake","text":"This document outlines the process to be followed when introducing a new jsii target language, including an estimated timeline (the exact timeline may vary significantly depending on the specifics of the language being added). The estimated total duration for the process is 4 to 6 months.","title":"New Language Intake"},{"location":"specification/5-new-language-intake/#planning","text":"Estimated Duration: 2 weeks The first step is to study the jsii specification, as well as existing language implementations, in order to have the knowledge necessary to write a new language support proposal RFC . The RFC document produced will evolve and be polished as development of the new language support progresses, but the following elements must be present before any implementation begins: Identification of the language's standard package repository Proposal for the binding's configuration block Sample API representations in the proposed language In particular, any element from the jsii type model that does not naturally map into the proposed new language needs to be represented Where several options exist, links to prior art are instrumental to validate the direction chosen Toolchain and platform requirements","title":"Planning"},{"location":"specification/5-new-language-intake/#code-generation-jsii-pacmak","text":"Estimated Duration: 4 to 6 weeks The necessary code must be added to [ jsii-pacmak ] in order to map the jsii assembly's declared types into the proposed language. While this code ought to leverage the new language's host runtime library, we begin with writing the code generator in order to ensure the appropriate developer experience is achieved in the new language before writing the back-end components. Code generators are authored in TypeScript . The necessary reserved words need to be registered in the jsii compiler, so that warnings are produced when identifiers are used in TypeScript code that require slugification or escaping in the target language (and will hence cause a degraded developer experience).","title":"Code Generation (jsii-pacmak)"},{"location":"specification/5-new-language-intake/#runtime-library","text":"Estimated Duration: 4 to 6 weeks Now that the appropriate developer experience has been identified, the host runtime library supporting the generated code can be written. This component must be written in the new language. Unimplemented A reference architecture for host runtime libraries is to be developed, in order to ensure consistent naming and behavior across all the runtimes, reducing the cost of maintaining many of those.","title":"Runtime Library"},{"location":"specification/5-new-language-intake/#building-packaging","text":"Estimated Duration: 2 weeks Once code is generated and it has a host runtime library to rely on, [ jsii-pacmak ] needs to receive the additional logic required to compile and package the generated libraries as required, producing ready-to-publish artifacts. The necessary toolchain needs to be added to the [ jsii/superchain ] Docker image, so that jsii customers can rely on this to build artifacts for any of the supported languages. In addition to this, standardized Amazon CodePipeline actions need to be developed in order to support publishing to the relevant idiomatic package managers.","title":"Building &amp; Packaging"},{"location":"specification/5-new-language-intake/#compliance-tests","text":"Estimated Duration: 6 weeks The full standard compliance suite must be implemented for the new language. Leveraging the new code generator, host runtime library and compilation logic, the tests demonstrate that the new library behaves consistently with all other language bindings. While it is possible to declare developer preview on a new language before all the tests pass, full compliance is a pre-requisite to declaring general availability of the new language.","title":"Compliance Tests"},{"location":"specification/5-new-language-intake/#documentation","text":"Estimated Duration: 1 week The necessary documentation needs to be provided to support customers who want to onboard the new language. This also includes updating [ jsii-config ] with support for the new languages' configuration block.","title":"Documentation"},{"location":"specification/5-new-language-intake/#developer-preview","text":"Recommended Duration: 4 to 8 weeks It is possible to declare Developer Preview for a new language support as soon as the code generation and host runtime library are mature enough to be useful, and cover the majority of use-cases. While certain edge-cases may still be uncovered at the beginning of Developer Preview , a clear plan should exist that ensures a path exists to address any known gaps. It is required to have implemented most of the standard compliance suite prior to declaring Developer Preview . During the Developer Preview phase, user experience studies should be conducted to validate assumptions made during the code generator's design. If any significant change is dictated by the results of the user experience studies, fluback studies should be performed in order to confirm that the desired impact has been achieved. Unimplemented A standard set of user experience study tasks will be developed, ensuring the learnings from previous experiences is factored into subsequent studies conducted. Finally, it is essential to give time to the community to use and vet the new language support prior to considering General Availability . A minimum of a full month without a major bug reported is advised. During this period, intentional hands-on usage of the product msut be performed by engineers familiar with the new language as well as engineers unfamilar with it. This ensures the new experience is considered holistically, in a manner unbiased by knowledge of the implementation.","title":"Developer Preview"},{"location":"specification/5-new-language-intake/#general-availability","text":"Once the new language support has been Developer Preview for long enough and the engineers involved have gained confidence that the API is stable, covers all known use-cases reliably, and behaves consistently with other Generally Available languages, the new support can be considered for General Availability .","title":"General Availability"},{"location":"specification/6-compliance-report/","text":"Compliance Report This section details the current state of each language binding with respect to our standard compliance suite. number test java (98.33%) golang (79.17%) Dotnet Python 1 asyncOverrides_overrideCallsSuper \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 2 arrayReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 3 unionProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 4 syncOverrides \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 5 useEnumFromScopedModule \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 6 createObjectAndCtorOverloads \ud83d\udfe2 \u26aa \u2b55 \u2b55 7 fail_syncOverrides_callsDoubleAsync_method \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 8 collectionOfInterfaces_MapOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 9 asyncOverrides_overrideAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 10 statics \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 11 structs_returnedLiteralEqualsNativeBuilt \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 12 classesCanSelfReferenceDuringClassInitialization \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 13 canObtainStructReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 14 callbacksCorrectlyDeserializeArguments \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 15 canUseInterfaceSetters \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 16 propertyOverrides_interfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 17 syncOverrides_callsSuper \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 18 testJsiiAgent \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 19 doNotOverridePrivates_method_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 20 pureInterfacesCanBeUsedTransparently \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 21 nullShouldBeTreatedAsUndefined \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 22 primitiveTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 23 reservedKeywordsAreSlugifiedInClassProperties \ud83d\udfe2 \u26aa \u2b55 \u2b55 24 objectIdDoesNotGetReallocatedWhenTheConstructorPassesThisOut \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 25 interfaceBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 26 unionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 27 arrays \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 28 staticMapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 29 consts \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 30 pureInterfacesCanBeUsedTransparently_WhenTransitivelyImplementing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 31 reservedKeywordsAreSlugifiedInMethodNames \ud83d\udfe2 \u26aa \u2b55 \u2b55 32 exceptions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 33 testLiteralInterface \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 34 structs_nonOptionalhashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 35 propertyOverrides_set_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 36 canLeverageIndirectInterfacePolymorphism \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 37 fluentApi \ud83d\udfe2 \u26aa \u2b55 \u2b55 38 staticListInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 39 mapReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 40 receiveInstanceOfPrivateClass \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 41 staticMapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 42 testNativeObjectsWithInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 43 doNotOverridePrivates_property_getter_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 44 equalsIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 45 listInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 46 useNestedStruct \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 47 testFluentApiWithDerivedClasses \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 48 interfacesCanBeUsedTransparently_WhenAddedToJsiiType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 49 canOverrideProtectedGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 50 getAndSetEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 51 structs_nonOptionalequals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 52 testInterfaceParameter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 53 liftedKwargWithSameNameAsPositionalArg \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 54 creationOfNativeObjectsFromJavaScriptObjects \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 55 canOverrideProtectedMethod \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 56 canLoadEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 57 eraseUnsetDataValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 58 maps \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 59 structs_containsNullChecks \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 60 canOverrideProtectedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 61 asyncOverrides_callAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 62 nodeStandardLibrary \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 63 dates \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 64 collectionOfInterfaces_ListOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 65 objRefsAreLabelledUsingWithTheMostCorrectType \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 66 unionPropertiesWithBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 67 doNotOverridePrivates_property_getter_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 68 structs_withDiamondInheritance_correctlyDedupeProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 69 abstractMembersAreCorrectlyHandled \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 70 doNotOverridePrivates_property_by_name_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 71 testNullIsAValidOptionalMap \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 72 mapReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 73 structs_multiplePropertiesEquals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 74 mapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 75 staticListInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 76 collectionOfInterfaces_MapOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 77 asyncOverrides_overrideThrows \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 78 callMethods \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 79 returnAbstract \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 80 dynamicTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 81 hashCodeIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \u26aa \u2b55 \u2b55 82 returnSubclassThatImplementsInterface976 \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 83 structs_optionalEquals \ud83d\udfe2 \u26aa \u2b55 \u2b55 84 propertyOverrides_get_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 85 unmarshallIntoAbstractType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 86 structs_multiplePropertiesHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 87 fail_syncOverrides_callsDoubleAsync_propertyGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 88 propertyOverrides_get_set \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 89 variadicMethodCanBeInvoked \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 90 collectionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 91 asyncOverrides_overrideAsyncMethodByParentClass \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 92 structs_optionalHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 93 testStructsCanBeDowncastedToParentType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 94 propertyOverrides_get_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 95 getSetPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 96 getAndSetNonPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 97 reservedKeywordsAreSlugifiedInStructProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 98 fail_syncOverrides_callsDoubleAsync_propertySetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 99 doNotOverridePrivates_method_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 100 testNullIsAValidOptionalList \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 101 mapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 102 doNotOverridePrivates_property_by_name_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 103 asyncOverrides_twoOverrides \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 104 propertyOverrides_set_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 105 iso8601DoesNotDeserializeToDate \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 106 collectionOfInterfaces_ListOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 107 undefinedAndNull \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 108 structs_serializeToJsii \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 109 structsAreUndecoratedOntheWayToKernel \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 110 canObtainReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 111 testJSObjectLiteralToNative \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 112 structs_stepBuilders \ud83d\udfe2 \u26aa \u2b55 \u2b55 113 classWithPrivateConstructorAndAutomaticProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 114 arrayReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 115 correctlyDeserializesStructUnions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 116 subclassing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 117 testInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 118 callbackParameterIsInterface \u2b55 \ud83d\udfe2 \u2b55 \u2b55 119 classCanBeUsedWhenNotExpressedlyLoaded \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 120 downcasting \u2b55 \ud83d\udfe2 \u2b55 \u2b55","title":"Compliance Report"},{"location":"specification/6-compliance-report/#compliance-report","text":"This section details the current state of each language binding with respect to our standard compliance suite. number test java (98.33%) golang (79.17%) Dotnet Python 1 asyncOverrides_overrideCallsSuper \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 2 arrayReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 3 unionProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 4 syncOverrides \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 5 useEnumFromScopedModule \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 6 createObjectAndCtorOverloads \ud83d\udfe2 \u26aa \u2b55 \u2b55 7 fail_syncOverrides_callsDoubleAsync_method \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 8 collectionOfInterfaces_MapOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 9 asyncOverrides_overrideAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 10 statics \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 11 structs_returnedLiteralEqualsNativeBuilt \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 12 classesCanSelfReferenceDuringClassInitialization \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 13 canObtainStructReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 14 callbacksCorrectlyDeserializeArguments \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 15 canUseInterfaceSetters \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 16 propertyOverrides_interfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 17 syncOverrides_callsSuper \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 18 testJsiiAgent \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 19 doNotOverridePrivates_method_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 20 pureInterfacesCanBeUsedTransparently \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 21 nullShouldBeTreatedAsUndefined \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 22 primitiveTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 23 reservedKeywordsAreSlugifiedInClassProperties \ud83d\udfe2 \u26aa \u2b55 \u2b55 24 objectIdDoesNotGetReallocatedWhenTheConstructorPassesThisOut \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 25 interfaceBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 26 unionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 27 arrays \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 28 staticMapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 29 consts \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 30 pureInterfacesCanBeUsedTransparently_WhenTransitivelyImplementing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 31 reservedKeywordsAreSlugifiedInMethodNames \ud83d\udfe2 \u26aa \u2b55 \u2b55 32 exceptions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 33 testLiteralInterface \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 34 structs_nonOptionalhashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 35 propertyOverrides_set_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 36 canLeverageIndirectInterfacePolymorphism \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 37 fluentApi \ud83d\udfe2 \u26aa \u2b55 \u2b55 38 staticListInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 39 mapReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 40 receiveInstanceOfPrivateClass \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 41 staticMapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 42 testNativeObjectsWithInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 43 doNotOverridePrivates_property_getter_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 44 equalsIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 45 listInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 46 useNestedStruct \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 47 testFluentApiWithDerivedClasses \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 48 interfacesCanBeUsedTransparently_WhenAddedToJsiiType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 49 canOverrideProtectedGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 50 getAndSetEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 51 structs_nonOptionalequals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 52 testInterfaceParameter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 53 liftedKwargWithSameNameAsPositionalArg \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 54 creationOfNativeObjectsFromJavaScriptObjects \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 55 canOverrideProtectedMethod \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 56 canLoadEnumValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 57 eraseUnsetDataValues \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 58 maps \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 59 structs_containsNullChecks \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 60 canOverrideProtectedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 61 asyncOverrides_callAsyncMethod \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 62 nodeStandardLibrary \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 63 dates \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 64 collectionOfInterfaces_ListOfStructs \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 65 objRefsAreLabelledUsingWithTheMostCorrectType \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 66 unionPropertiesWithBuilder \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 67 doNotOverridePrivates_property_getter_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 68 structs_withDiamondInheritance_correctlyDedupeProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 69 abstractMembersAreCorrectlyHandled \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 70 doNotOverridePrivates_property_by_name_private \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 71 testNullIsAValidOptionalMap \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 72 mapReturnedByMethodCanBeRead \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 73 structs_multiplePropertiesEquals \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 74 mapInClassCanBeReadCorrectly \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 75 staticListInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 76 collectionOfInterfaces_MapOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 77 asyncOverrides_overrideThrows \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 78 callMethods \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 79 returnAbstract \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 80 dynamicTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 81 hashCodeIsResistantToPropertyShadowingResultVariable \ud83d\udfe2 \u26aa \u2b55 \u2b55 82 returnSubclassThatImplementsInterface976 \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 83 structs_optionalEquals \ud83d\udfe2 \u26aa \u2b55 \u2b55 84 propertyOverrides_get_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 85 unmarshallIntoAbstractType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 86 structs_multiplePropertiesHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 87 fail_syncOverrides_callsDoubleAsync_propertyGetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 88 propertyOverrides_get_set \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 89 variadicMethodCanBeInvoked \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 90 collectionTypes \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 91 asyncOverrides_overrideAsyncMethodByParentClass \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 92 structs_optionalHashCode \ud83d\udfe2 \u26aa \u2b55 \u2b55 93 testStructsCanBeDowncastedToParentType \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 94 propertyOverrides_get_throws \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 95 getSetPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 96 getAndSetNonPrimitiveProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 97 reservedKeywordsAreSlugifiedInStructProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 98 fail_syncOverrides_callsDoubleAsync_propertySetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 99 doNotOverridePrivates_method_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 100 testNullIsAValidOptionalList \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 101 mapInClassCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 102 doNotOverridePrivates_property_by_name_public \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 103 asyncOverrides_twoOverrides \ud83d\udfe2 \ud83d\udd34 \u2b55 \u2b55 104 propertyOverrides_set_calls_super \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 105 iso8601DoesNotDeserializeToDate \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 106 collectionOfInterfaces_ListOfInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 107 undefinedAndNull \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 108 structs_serializeToJsii \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 109 structsAreUndecoratedOntheWayToKernel \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 110 canObtainReferenceWithOverloadedSetter \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 111 testJSObjectLiteralToNative \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 112 structs_stepBuilders \ud83d\udfe2 \u26aa \u2b55 \u2b55 113 classWithPrivateConstructorAndAutomaticProperties \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 114 arrayReturnedByMethodCannotBeModified \ud83d\udfe2 \u26aa \u2b55 \u2b55 115 correctlyDeserializesStructUnions \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 116 subclassing \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 117 testInterfaces \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 118 callbackParameterIsInterface \u2b55 \ud83d\udfe2 \u2b55 \u2b55 119 classCanBeUsedWhenNotExpressedlyLoaded \ud83d\udfe2 \ud83d\udfe2 \u2b55 \u2b55 120 downcasting \u2b55 \ud83d\udfe2 \u2b55 \u2b55","title":"Compliance Report"},{"location":"user-guides/","text":"Introduction This section of the jsii reference contains user-guides for different audiences. The below sections provide an overview of each section. Library author guide The library author guide provides information to developers who want to use the jsii toolchain to author libraries that will be usable from all supported programming languages. It contains important information on TypeScript restrictions , as well as the language binding configuration reference . Library consumer guide The library consumer guide provides specific information intended for developers leveraging libraries generated by the jsii toolchain . In particular, it provides guidance for how to correctly use those libraries, in cases where the generated bindings are somewhat non-idiomatic. Language implementation guide The language implementation guide provides information to developers who are interested in contributing support for a new language in the jsii toolchain .","title":"Introduction"},{"location":"user-guides/#introduction","text":"This section of the jsii reference contains user-guides for different audiences. The below sections provide an overview of each section.","title":"Introduction"},{"location":"user-guides/#library-author-guide","text":"The library author guide provides information to developers who want to use the jsii toolchain to author libraries that will be usable from all supported programming languages. It contains important information on TypeScript restrictions , as well as the language binding configuration reference .","title":"Library author guide"},{"location":"user-guides/#library-consumer-guide","text":"The library consumer guide provides specific information intended for developers leveraging libraries generated by the jsii toolchain . In particular, it provides guidance for how to correctly use those libraries, in cases where the generated bindings are somewhat non-idiomatic.","title":"Library consumer guide"},{"location":"user-guides/#language-implementation-guide","text":"The language implementation guide provides information to developers who are interested in contributing support for a new language in the jsii toolchain .","title":"Language implementation guide"},{"location":"user-guides/language-support/","text":"Language Implementation This handbook provides an overview of the process that should be followed when looking to implement support for a new programming language in jsii . It attempts to provide a step-by-step procedure, while drawing the reader's attention on points that have been found to cause problems in the past. Foreword Implementing a new language in jsii is not just a matter of implementing code generation. Mapping the jsii type system to a new programming language means finding how to represent an API originally designed in TypeScript to a form that is as idiomatic as possible in the new language. This is a craft that often requires trial and error, and the best (if not only) way to validate a proposal is to put it in front of users and seek feedback. As a consequence, this endeavor should be expected to span months, not weeks. Scoping & Planning The first step of most successful projects is to start by scoping work out and establishing a baseline plan to execute on. For contributors not yet familiar with jsii , the specification document is a great place to start. In particular, the New Language Intake document provides a high-level view of the recommended process for implementing new language support. The work of implementing support for a new language involves many different components: The [ jsii ] compiler emits warnings when a language's reserved words are used to name types, methods or properties; as this will later require slugification or escaping in the generated code - usually resulting in a degraded developer experience. The [ jsii-pacmak ] tool includes code generators for all supported languages, and a new implementation must be provided for the new language. Code generation usually requires specific configuration to be provided in order to be able to generate valid packages (for example, the Java code generator requires a base java package to generate into, as well as a Maven group and artifact ID for the package). The [ jsii-config ] tool needs to be updated with support generating a configuration block with the required entries for the new code generator. [ jsii-rosetta ] tool translates TypeScript example code found in the original documentation into the new target language. A new translation implementation needs to be added for the new language. Building and publishing infrastructure elements are provided by [ aws-delivlib ] to make it easier for jsii users to publish their libraries to all supported package registries. Language Proposition RFC The recommended way to formalize the initial plan is to write it into an RFC hosted in the CDK RFC repository . Enough time has to be spent considering the requirements in order to get the work scoped and planned well, ensuring smooth execution. An additional benefit of following the RFC process is that it makes it easier to track learnings accumulated through the implementation process, as those will be tracked as comments or iterations on the RFC document. It is possible (and sometimes desirable) to start prototyping code-generation for the new language, as this can highlight implementation challenges that need to be discussed in the RFC document. In any case, examples of the API signatures that are expected to be rendered allow early feedback to be provided by possible future users, and still helps identify challenges. The following questions should be answered as early as possible in the process, to avoid surprises later on that result in significant re-engineering effort: What do the generated APIs look like, for the typical API idioms? Classes (constructors, properties, methods, inheritance strategy, abstract members, ...) The AWS CDK (one of the main consumers of jsii ) uses specific patterns to offer a better experience in many programming languages. For example, constructor signatures where the last argument is a jsii struct allows for keyword argument lifting in Python , and convenient Builder APIs in Java . Enums Interfaces and Structs (properties, methods, inheritance strategy, implementation, ...). In particular, how are new optional properties handled (those are not considered breaking change within the jsii type system ). Structs (properties, inheritance strategy, implementation, ...) What information is needed in order for the code-generator to produce artifacts? What should the configuration block look like? What is the standard way to publish packages for the new language? Are there any requirements (code signature, special metadata, ...) that need to be implemented in order to publish valid packages? How are dependencies modeled? If semantic versioning is not the norm, what is the strategy to correctly represent semantic version ranges? What are the toolchain and platform requirements? For example, Java requires an OpenJDK 8 distribution and maven , Python requires python 3.7 or above, etc... Code Generation First, implement a first version of the code generation for the new language before getting too far into the host library implementation. This top-down approach ensures the requirements for the lower level parts of the implementation are well-defined before they are implemented (reducing the chances that significant re-work has to be done), and enables using the Standard Compliance Suite to ensure the overall implementation is correct according to the specification (since the code necessary to implement the test cases will be available right from the start). This work happens within the [ jsii-pacmak ] package. Focus initially on the API signatures before getting into their implementation. The first version may even throw a not implemented exception when called. The [ jsii-calc ] package, can be used as a sample consuming library which uses jsii to generate code in all target languages. Start by making sure a decent API is generated from this package and its dependencies, and use those to implement the tests from the Standard Compliance Suite . You'll also get a feeling for whether the generated code achieves a good developer experience or not. Host Library Now that we are generating \"empty shell\" APIs that represent the necessary entities to back the Standard Compliance Suite tests, start implementing the host library and update the code generator until all the tests pass. It is possible to publish artifacts even when tests in the suite are failing. As soon as basic features are working, work on Building and Packaging can start, so early feedback can be gathered. Unimplemented A standard architecture for the host library has not been documented yet. Upcoming language implementations should contribute to this process by documenting a general architecture that should be implementable in any programming languages (and thus, abstracting away language specificities). Building & Packaging The necessary toolchains should be added to he [ jsii/superchain ] Docker image, so that the [ jsii-pacmak ] generation can be changed to support building ready to publish artifacts instead of just code. Before publishing any artifacts, ensure all packages (the host library as well as generated artifacts) are designated as experimental (e.g: Python packages were annotated with the Development Status :: 4 - Beta trove classifier on PyPI, and NuGet packages were published with a pre-release version such as 1.2.3-pre ). Additionally, [ aws-delivlib ] needs to be augmented to support publishing artifacts to the language's package repository. Unimplemented The package publishing is being extracted from [ aws-delivlib ] into a standalone library, currently hosted at eladb/jsii-release . Documentation Before releasing the new language support to Developer Preview , basic documentation needs to be produced to explain how to configure a jsii project to support the new language, and any peculiarities in working with libraries generated by [ jsii-pacmak ] for this language. Support for example code translation should also be built into [ jsii-rosetta ]. Developer Preview Once the full Standard Compliance Suite passes (possibly with the exception of certain fringy features), and the documentation covering all aspects of using the language bindings have been produced, the new language can be released to Developer Preview . It is recommended that new languages stay in Developer Preview for a minimum of 4 weeks, ideally until they have received sufficient usage to have built confidence that there are no major usability concerns: once out of Developer Preview , it will no longer be possible to introduce breaking changes to the generated code in order to address usability issues or bugs. In order to improve the chances of catching usability issues, focused user experience studies will be conducted with an audience composed of developers with varied degrees of experience with the new language. Unimplemented A user experience template will be provided to ensure coverage of critical aspects of the experience. Any critical user experience issue (for example, issues that required breaking changes to the generated code) discovered but not covered in the template should be added to the template so that subsequent language implementations do not fall to the same problem. General Availability Once the new language has been in Developer Preview without any significant usability issues or bugs for a sufficient amount of time and is used in real-world use-cases such as for AWS CDK applications, it becomes a candidate to be declared Generally Available . At this point, breaking changes are no longer possible on the generated code.","title":"Language Implementation"},{"location":"user-guides/language-support/#language-implementation","text":"This handbook provides an overview of the process that should be followed when looking to implement support for a new programming language in jsii . It attempts to provide a step-by-step procedure, while drawing the reader's attention on points that have been found to cause problems in the past.","title":"Language Implementation"},{"location":"user-guides/language-support/#foreword","text":"Implementing a new language in jsii is not just a matter of implementing code generation. Mapping the jsii type system to a new programming language means finding how to represent an API originally designed in TypeScript to a form that is as idiomatic as possible in the new language. This is a craft that often requires trial and error, and the best (if not only) way to validate a proposal is to put it in front of users and seek feedback. As a consequence, this endeavor should be expected to span months, not weeks.","title":"Foreword"},{"location":"user-guides/language-support/#scoping-planning","text":"The first step of most successful projects is to start by scoping work out and establishing a baseline plan to execute on. For contributors not yet familiar with jsii , the specification document is a great place to start. In particular, the New Language Intake document provides a high-level view of the recommended process for implementing new language support. The work of implementing support for a new language involves many different components: The [ jsii ] compiler emits warnings when a language's reserved words are used to name types, methods or properties; as this will later require slugification or escaping in the generated code - usually resulting in a degraded developer experience. The [ jsii-pacmak ] tool includes code generators for all supported languages, and a new implementation must be provided for the new language. Code generation usually requires specific configuration to be provided in order to be able to generate valid packages (for example, the Java code generator requires a base java package to generate into, as well as a Maven group and artifact ID for the package). The [ jsii-config ] tool needs to be updated with support generating a configuration block with the required entries for the new code generator. [ jsii-rosetta ] tool translates TypeScript example code found in the original documentation into the new target language. A new translation implementation needs to be added for the new language. Building and publishing infrastructure elements are provided by [ aws-delivlib ] to make it easier for jsii users to publish their libraries to all supported package registries.","title":"Scoping &amp; Planning"},{"location":"user-guides/language-support/#language-proposition-rfc","text":"The recommended way to formalize the initial plan is to write it into an RFC hosted in the CDK RFC repository . Enough time has to be spent considering the requirements in order to get the work scoped and planned well, ensuring smooth execution. An additional benefit of following the RFC process is that it makes it easier to track learnings accumulated through the implementation process, as those will be tracked as comments or iterations on the RFC document. It is possible (and sometimes desirable) to start prototyping code-generation for the new language, as this can highlight implementation challenges that need to be discussed in the RFC document. In any case, examples of the API signatures that are expected to be rendered allow early feedback to be provided by possible future users, and still helps identify challenges. The following questions should be answered as early as possible in the process, to avoid surprises later on that result in significant re-engineering effort: What do the generated APIs look like, for the typical API idioms? Classes (constructors, properties, methods, inheritance strategy, abstract members, ...) The AWS CDK (one of the main consumers of jsii ) uses specific patterns to offer a better experience in many programming languages. For example, constructor signatures where the last argument is a jsii struct allows for keyword argument lifting in Python , and convenient Builder APIs in Java . Enums Interfaces and Structs (properties, methods, inheritance strategy, implementation, ...). In particular, how are new optional properties handled (those are not considered breaking change within the jsii type system ). Structs (properties, inheritance strategy, implementation, ...) What information is needed in order for the code-generator to produce artifacts? What should the configuration block look like? What is the standard way to publish packages for the new language? Are there any requirements (code signature, special metadata, ...) that need to be implemented in order to publish valid packages? How are dependencies modeled? If semantic versioning is not the norm, what is the strategy to correctly represent semantic version ranges? What are the toolchain and platform requirements? For example, Java requires an OpenJDK 8 distribution and maven , Python requires python 3.7 or above, etc...","title":"Language Proposition RFC"},{"location":"user-guides/language-support/#code-generation","text":"First, implement a first version of the code generation for the new language before getting too far into the host library implementation. This top-down approach ensures the requirements for the lower level parts of the implementation are well-defined before they are implemented (reducing the chances that significant re-work has to be done), and enables using the Standard Compliance Suite to ensure the overall implementation is correct according to the specification (since the code necessary to implement the test cases will be available right from the start). This work happens within the [ jsii-pacmak ] package. Focus initially on the API signatures before getting into their implementation. The first version may even throw a not implemented exception when called. The [ jsii-calc ] package, can be used as a sample consuming library which uses jsii to generate code in all target languages. Start by making sure a decent API is generated from this package and its dependencies, and use those to implement the tests from the Standard Compliance Suite . You'll also get a feeling for whether the generated code achieves a good developer experience or not.","title":"Code Generation"},{"location":"user-guides/language-support/#host-library","text":"Now that we are generating \"empty shell\" APIs that represent the necessary entities to back the Standard Compliance Suite tests, start implementing the host library and update the code generator until all the tests pass. It is possible to publish artifacts even when tests in the suite are failing. As soon as basic features are working, work on Building and Packaging can start, so early feedback can be gathered. Unimplemented A standard architecture for the host library has not been documented yet. Upcoming language implementations should contribute to this process by documenting a general architecture that should be implementable in any programming languages (and thus, abstracting away language specificities).","title":"Host Library"},{"location":"user-guides/language-support/#building-packaging","text":"The necessary toolchains should be added to he [ jsii/superchain ] Docker image, so that the [ jsii-pacmak ] generation can be changed to support building ready to publish artifacts instead of just code. Before publishing any artifacts, ensure all packages (the host library as well as generated artifacts) are designated as experimental (e.g: Python packages were annotated with the Development Status :: 4 - Beta trove classifier on PyPI, and NuGet packages were published with a pre-release version such as 1.2.3-pre ). Additionally, [ aws-delivlib ] needs to be augmented to support publishing artifacts to the language's package repository. Unimplemented The package publishing is being extracted from [ aws-delivlib ] into a standalone library, currently hosted at eladb/jsii-release .","title":"Building &amp; Packaging"},{"location":"user-guides/language-support/#documentation","text":"Before releasing the new language support to Developer Preview , basic documentation needs to be produced to explain how to configure a jsii project to support the new language, and any peculiarities in working with libraries generated by [ jsii-pacmak ] for this language. Support for example code translation should also be built into [ jsii-rosetta ].","title":"Documentation"},{"location":"user-guides/language-support/#developer-preview","text":"Once the full Standard Compliance Suite passes (possibly with the exception of certain fringy features), and the documentation covering all aspects of using the language bindings have been produced, the new language can be released to Developer Preview . It is recommended that new languages stay in Developer Preview for a minimum of 4 weeks, ideally until they have received sufficient usage to have built confidence that there are no major usability concerns: once out of Developer Preview , it will no longer be possible to introduce breaking changes to the generated code in order to address usability issues or bugs. In order to improve the chances of catching usability issues, focused user experience studies will be conducted with an audience composed of developers with varied degrees of experience with the new language. Unimplemented A user experience template will be provided to ensure coverage of critical aspects of the experience. Any critical user experience issue (for example, issues that required breaking changes to the generated code) discovered but not covered in the template should be added to the template so that subsequent language implementations do not fall to the same problem.","title":"Developer Preview"},{"location":"user-guides/language-support/#general-availability","text":"Once the new language has been in Developer Preview without any significant usability issues or bugs for a sufficient amount of time and is used in real-world use-cases such as for AWS CDK applications, it becomes a candidate to be declared Generally Available . At this point, breaking changes are no longer possible on the generated code.","title":"General Availability"},{"location":"user-guides/language-support/assembly/","text":".jsii Assemblies This document describes the contents of the .jsii assembly documents generated by the jsii compiler, and explains the semantics behind the various entities it represents. This serves as a reference for front-end language implementors. Schema .jsii assemblies are JSON-formatted documents. The specification is hosted under the jsii-spec package. Refer to the inline documentation in the spec.ts file for more information about the general content of the assembly documents. The most important part of the assembly documentation, which is described in detail in this document, is the types map, which contains the descriptions of all types declared by the .jsii assembly. It is a map from jsii fully- qualified type names to a type specification. All boolean attributes in the document specification are optional, and are left out ( undefined ) when false . Common Attributes Certain optional attributes are shared by API entities (types and members): docs - documentation attached to the API entity deprecated - contains a message explaining why an API was deprecated and/or how users should migrate away stability - the stability level of the API entity. The ultimate meaning of the stability level is up to the package maintainer, but a baseline interpretation of the valid values follows: experimental denotes an API that is actively worked on and are not subject to semantic versioning gurantees (they may receive breaking change on a minor version release) stable denotes an API that is safe to use in production systems and are subject ot semantic versioning guarantees (they may not receive breaking changes without a major version bump) deprecated denotes an API that should no longer be used. The deprecated entry in the docs object should contain a message explaining how users should migrate away external denotes an API that is not owned by the package's maintainer and may change in unexpected ways. Such APIs are usually derived from external artifacts, which the package maintainers do not have control over. additional entries represent user-defined JSDoc tags with meaning defined by convention and/or the package maintainer locationInModule - coordinates of the declaration in the source fileName - the path to the source file, relative to the package root line - the line number on which the entity is declared (or the first line when a declaration spans multiple lines) Types Classes Attribute Type Description kind 'class' Discriminator to identify classes abstract boolean Whether this class is abstract assembly string The name of the assembly this class is a part of base string The fully-qualified name of the parent class of this class fqn string The fully-qualified name of the class initializer Constructor The class' constructor interfaces string[] The fully-qualified names of interfaces implemented by this class methods Method[] The methods declared by this class name string The simple name of the class properties Property[] The properties declared by this class Interfaces jsii interfaces are declarations of type signatures that can be implemented by classes. Interface names must be prefixed with an I (e.g: IFoo ). Attribute Type Description kind 'interface' Discriminator to identify interfaces assembly string The name of the assembly this interface is a part of fqn string The fully-qualified name of the interface interfaces string[] The fully-qualified names of interfaces extended by this interface methods Method[] The methods declared by this interface name string The simple name of the interface properties Property[] The properties declared by this interface Structs (a.k.a. Data Types) Structs (or Data Types ) are immutable, data-only interfaces: They declare no methods All properties they declare are readonly They can only implement other structs They cannot be extended by interfaces that are not structs They cannot be implemented by classes Unlike regular interfaces , jsii struct names are not required to have any particular prefix. Since those are immutable, pure data objects, the jsii-runtime exchanges instances of those by value , instead of by reference , allowing to save cross-language communication overhead when working with the data. Attribute Type Description kind 'interface' Discriminator to identify interfaces datatype true Indicates a struct / data type declaration assembly string The name of the assembly this struct is a part of fqn string The fully-qualified name of the struct interfaces string[] The fully-qualified names of struct extended by this struct name string The simple name of the struct properties Property[] The properties declared by this struct (all readonly ) Enums Attribute Type Description kind 'enum' Discriminator to identify enums assembly string The name of the assembly this enum is a part of fqn string The fully-qualified name of the enum members EnumMember[] The enum members declared by this enum name string The simple name of the enum Members Constructors Attribute Type Description overrides string The fully-qualified name of the class/interface that declares the overridden constructor parameters Parameter[] Parameters of this constructor protected boolean Whether this constructor is protected variadic boolean Whether the last parameter is variadic Enum Members Attribute Type Description name string The name of the enum member. Must be UPPER_SNAKE_CASED Methods Attribute Type Description abstract boolean Whether this method is abstract async boolean Whether this method is asynchronous name string The name of the method overrides string The fully-qualified name of the class/interface that declares the overridden method parameters Parameter[] Parameters of this method protected boolean Whether this method is protected returns OptionalValue The return type of the method static boolean Whether this method is static variadic boolean Whether the last parameter is variadic Methods with the abstract feature may only be members of abstract classes or interfaces , and all methods that are members of interfaces must be abstract . Methods that are static cannot feature the overrides attribute, as static members are not inherited. Properties Attribute Type Description abstract boolean Whether this property is abstract const boolean Whether this property is a constant (implies static and immutable ) immutable boolean Whether this property is immutable name string The name of the property optional boolean Whether this property is optional overrides string The fully-qualified name of the class/interface that declares the overridden property protected boolean Whether this constructor is protected static boolean Whether this property is static type TypeReference The type of the property Properties that are const must have a name that is UPPER_SNAKE_CASED . They represent constants similar to Enum Members , which can be proactively resolved by the jsii runtimes. Danger Properties and methods that are static can feature the overrides attribute, as static members are inherited with the prototype in JavaScript (as part of the ES6 specification). Not all target languages have this capability (most, like C# and Java , only support hiding static declarations), and consequently code generators may ignore this (or explicitly hide parent declarations) instead.","title":".jsii Assemblies"},{"location":"user-guides/language-support/assembly/#jsii-assemblies","text":"This document describes the contents of the .jsii assembly documents generated by the jsii compiler, and explains the semantics behind the various entities it represents. This serves as a reference for front-end language implementors.","title":".jsii Assemblies"},{"location":"user-guides/language-support/assembly/#schema","text":".jsii assemblies are JSON-formatted documents. The specification is hosted under the jsii-spec package. Refer to the inline documentation in the spec.ts file for more information about the general content of the assembly documents. The most important part of the assembly documentation, which is described in detail in this document, is the types map, which contains the descriptions of all types declared by the .jsii assembly. It is a map from jsii fully- qualified type names to a type specification. All boolean attributes in the document specification are optional, and are left out ( undefined ) when false .","title":"Schema"},{"location":"user-guides/language-support/assembly/#common-attributes","text":"Certain optional attributes are shared by API entities (types and members): docs - documentation attached to the API entity deprecated - contains a message explaining why an API was deprecated and/or how users should migrate away stability - the stability level of the API entity. The ultimate meaning of the stability level is up to the package maintainer, but a baseline interpretation of the valid values follows: experimental denotes an API that is actively worked on and are not subject to semantic versioning gurantees (they may receive breaking change on a minor version release) stable denotes an API that is safe to use in production systems and are subject ot semantic versioning guarantees (they may not receive breaking changes without a major version bump) deprecated denotes an API that should no longer be used. The deprecated entry in the docs object should contain a message explaining how users should migrate away external denotes an API that is not owned by the package's maintainer and may change in unexpected ways. Such APIs are usually derived from external artifacts, which the package maintainers do not have control over. additional entries represent user-defined JSDoc tags with meaning defined by convention and/or the package maintainer locationInModule - coordinates of the declaration in the source fileName - the path to the source file, relative to the package root line - the line number on which the entity is declared (or the first line when a declaration spans multiple lines)","title":"Common Attributes"},{"location":"user-guides/language-support/assembly/#types","text":"","title":"Types"},{"location":"user-guides/language-support/assembly/#classes","text":"Attribute Type Description kind 'class' Discriminator to identify classes abstract boolean Whether this class is abstract assembly string The name of the assembly this class is a part of base string The fully-qualified name of the parent class of this class fqn string The fully-qualified name of the class initializer Constructor The class' constructor interfaces string[] The fully-qualified names of interfaces implemented by this class methods Method[] The methods declared by this class name string The simple name of the class properties Property[] The properties declared by this class","title":"Classes"},{"location":"user-guides/language-support/assembly/#interfaces","text":"jsii interfaces are declarations of type signatures that can be implemented by classes. Interface names must be prefixed with an I (e.g: IFoo ). Attribute Type Description kind 'interface' Discriminator to identify interfaces assembly string The name of the assembly this interface is a part of fqn string The fully-qualified name of the interface interfaces string[] The fully-qualified names of interfaces extended by this interface methods Method[] The methods declared by this interface name string The simple name of the interface properties Property[] The properties declared by this interface","title":"Interfaces"},{"location":"user-guides/language-support/assembly/#structs-aka-data-types","text":"Structs (or Data Types ) are immutable, data-only interfaces: They declare no methods All properties they declare are readonly They can only implement other structs They cannot be extended by interfaces that are not structs They cannot be implemented by classes Unlike regular interfaces , jsii struct names are not required to have any particular prefix. Since those are immutable, pure data objects, the jsii-runtime exchanges instances of those by value , instead of by reference , allowing to save cross-language communication overhead when working with the data. Attribute Type Description kind 'interface' Discriminator to identify interfaces datatype true Indicates a struct / data type declaration assembly string The name of the assembly this struct is a part of fqn string The fully-qualified name of the struct interfaces string[] The fully-qualified names of struct extended by this struct name string The simple name of the struct properties Property[] The properties declared by this struct (all readonly )","title":"Structs (a.k.a. Data Types)"},{"location":"user-guides/language-support/assembly/#enums","text":"Attribute Type Description kind 'enum' Discriminator to identify enums assembly string The name of the assembly this enum is a part of fqn string The fully-qualified name of the enum members EnumMember[] The enum members declared by this enum name string The simple name of the enum","title":"Enums"},{"location":"user-guides/language-support/assembly/#members","text":"","title":"Members"},{"location":"user-guides/language-support/assembly/#constructors","text":"Attribute Type Description overrides string The fully-qualified name of the class/interface that declares the overridden constructor parameters Parameter[] Parameters of this constructor protected boolean Whether this constructor is protected variadic boolean Whether the last parameter is variadic","title":"Constructors"},{"location":"user-guides/language-support/assembly/#enum-members","text":"Attribute Type Description name string The name of the enum member. Must be UPPER_SNAKE_CASED","title":"Enum Members"},{"location":"user-guides/language-support/assembly/#methods","text":"Attribute Type Description abstract boolean Whether this method is abstract async boolean Whether this method is asynchronous name string The name of the method overrides string The fully-qualified name of the class/interface that declares the overridden method parameters Parameter[] Parameters of this method protected boolean Whether this method is protected returns OptionalValue The return type of the method static boolean Whether this method is static variadic boolean Whether the last parameter is variadic Methods with the abstract feature may only be members of abstract classes or interfaces , and all methods that are members of interfaces must be abstract . Methods that are static cannot feature the overrides attribute, as static members are not inherited.","title":"Methods"},{"location":"user-guides/language-support/assembly/#properties","text":"Attribute Type Description abstract boolean Whether this property is abstract const boolean Whether this property is a constant (implies static and immutable ) immutable boolean Whether this property is immutable name string The name of the property optional boolean Whether this property is optional overrides string The fully-qualified name of the class/interface that declares the overridden property protected boolean Whether this constructor is protected static boolean Whether this property is static type TypeReference The type of the property Properties that are const must have a name that is UPPER_SNAKE_CASED . They represent constants similar to Enum Members , which can be proactively resolved by the jsii runtimes. Danger Properties and methods that are static can feature the overrides attribute, as static members are inherited with the prototype in JavaScript (as part of the ES6 specification). Not all target languages have this capability (most, like C# and Java , only support hiding static declarations), and consequently code generators may ignore this (or explicitly hide parent declarations) instead.","title":"Properties"},{"location":"user-guides/language-support/callbacks/","text":"Callbacks and Overrides This document provides a high-level overview of the mechanisms used by jsii to allow foreign code to override JavaScript methods. It details the responsibilities of the jsii kernel and of the foreign library , and provides implementation guidelines. Identifying Overrides The jsii kernel allows foreign code to register overrides for the following use-cases: Overriding a class' non-static member Implementing an abstract member (including interface members) Info It is possible for foreign code to override a class' constructor, but those cannot be registered in the jsii kernel as it cannot trigger instantiation of a foreign class directly. Foreign constructors always delegate to the JavaScript constructor, which is happens via the create operation, during which overrides are registered. All cases where foreign code should be executed in lieu of JavaScript code must be identified and declared properly, as the jsii kernel otherwise has no way to determine a foreign implementation exists. Where possible, the jsii runtime library for the foreign language will use reflection APIs to transparently discover which API elements are overridden or implemented. In cases where reflection is expensive, the jsii runtime library will try to cache findings as appropriate in order to avoid duplication of this effort. In case the foreign language does not have direct support for overriding (e.g: Go ), or lacks the necessary reflection tools to allow automatic identification of overrides, the jsii runtime library may expose APIs allowing users to register implementation overrides manually. Declaring Overrides The foreign library is responsible for declaring overrides to the jsii kernel . Those are declared for every object instance using the overrides property of the kernel.create request . Each entry in the overrides list declares an overriden property or method. Each override declaration may optionally include a cookie : this string will not be interpreted by the jsii kernel in any way, and will simply be passed back passed back with any request to invoke the overridden member's foreign implementation. Info It is possible to register overrides to members that do not formally exist on a type. Since the jsii kernel has no type information available for those, it will handle them as follows: Method overrides are assumed to have the following signature: overridden ( ...args : any []) : any Property overrides are assumed to be any -valued and mutable Danger This should generally be avoided as it can result in incoherent data serialization happening when the jsii kernel receives and returns values. Invoking Overrides Once object instances have been created in the jsii kernel with overrides, execution of JavaScript code may require executing foreign code. The jsii kernel signals this to the jsii runtime library by responding with a callback request instead of the typical response type for the original request (i.e: InvokeResponse , GetResponse or SetResponse ). Several such callbacks may be necessary in order to complete the original request. When the original request is finally able to complete, its response is returned. The jsii runtime library must respond to each callback request with a complete response, allowing the jsii kernel to resume fulfilling the original request. In order to do this, the jsii runtime library obtains the foreign object corresponding to the callback request 's receiver, then invokes the corresponding implementation (for example, using reflection). When needed, the original JavaScript implementation can be delegated to (many languages refer to this as super(...) or some similar idiom). Example Assuming we have the following TypeScript types defined: export abstract class FooClass { protected abstract baz : string ; public bar () : string { return this . reverse () ? Array . from ( this . baz ). reverse (). join ( '' ) : this . baz ; } protected reverse () : boolean { return false ; } } And we have the following Foreign application (assuming Java ): public final class Main extends FooClass { public static final void main ( final String [] args ) { final FooClass self = new Main (); System . out . println ( self . bar ()); } @Override public String getBaz () { return \"baz\" ; } @Override public boolean reverse () { return true ; } } The schematized exchange between the jsii runtime library and the jsii kernel is the following: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Kernel \u2503 \u2503Runtime Library\u2503 \u2517\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u251b \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u25c0\u2500\u2524 Create(FQN: \"FooClass\", Overrides=[\"baz\", \"reverse\"]) \u251c\u2500\u2500\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 OK(ObjID: \"Foo\") \u251c\u2500\u25b6\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u25c0\u2500\u2524 InvokeRequest(ObjID: \"Foo\", Method: \"bar\") \u251c\u2500\u2500\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 CallbackRequest(ID: 1, ObjID: \"Foo\", Invoke: \"reverse\") \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2502call \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2502obj(\"Foo\").reverse() \u2503\u25c0\u2500\u2524 Complete(CallbackID: 1, OK: true) \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 CallbackRequest(ID: 2, ObjID: \"Foo\", Get: \"baz\") \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2502get \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2502obj(\"Foo\").baz \u2503\u25c0\u2500\u2524 Complete(CallbackID: 2, OK: \"baz\") \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 InvokeResponse(OK: \"zab\") \u251c\u2500\u25b6\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u2503 See Also The jsii runtime architecture The jsii kernel API","title":"Callbacks and Overrides"},{"location":"user-guides/language-support/callbacks/#callbacks-and-overrides","text":"This document provides a high-level overview of the mechanisms used by jsii to allow foreign code to override JavaScript methods. It details the responsibilities of the jsii kernel and of the foreign library , and provides implementation guidelines.","title":"Callbacks and Overrides"},{"location":"user-guides/language-support/callbacks/#identifying-overrides","text":"The jsii kernel allows foreign code to register overrides for the following use-cases: Overriding a class' non-static member Implementing an abstract member (including interface members) Info It is possible for foreign code to override a class' constructor, but those cannot be registered in the jsii kernel as it cannot trigger instantiation of a foreign class directly. Foreign constructors always delegate to the JavaScript constructor, which is happens via the create operation, during which overrides are registered. All cases where foreign code should be executed in lieu of JavaScript code must be identified and declared properly, as the jsii kernel otherwise has no way to determine a foreign implementation exists. Where possible, the jsii runtime library for the foreign language will use reflection APIs to transparently discover which API elements are overridden or implemented. In cases where reflection is expensive, the jsii runtime library will try to cache findings as appropriate in order to avoid duplication of this effort. In case the foreign language does not have direct support for overriding (e.g: Go ), or lacks the necessary reflection tools to allow automatic identification of overrides, the jsii runtime library may expose APIs allowing users to register implementation overrides manually.","title":"Identifying Overrides"},{"location":"user-guides/language-support/callbacks/#declaring-overrides","text":"The foreign library is responsible for declaring overrides to the jsii kernel . Those are declared for every object instance using the overrides property of the kernel.create request . Each entry in the overrides list declares an overriden property or method. Each override declaration may optionally include a cookie : this string will not be interpreted by the jsii kernel in any way, and will simply be passed back passed back with any request to invoke the overridden member's foreign implementation. Info It is possible to register overrides to members that do not formally exist on a type. Since the jsii kernel has no type information available for those, it will handle them as follows: Method overrides are assumed to have the following signature: overridden ( ...args : any []) : any Property overrides are assumed to be any -valued and mutable Danger This should generally be avoided as it can result in incoherent data serialization happening when the jsii kernel receives and returns values.","title":"Declaring Overrides"},{"location":"user-guides/language-support/callbacks/#invoking-overrides","text":"Once object instances have been created in the jsii kernel with overrides, execution of JavaScript code may require executing foreign code. The jsii kernel signals this to the jsii runtime library by responding with a callback request instead of the typical response type for the original request (i.e: InvokeResponse , GetResponse or SetResponse ). Several such callbacks may be necessary in order to complete the original request. When the original request is finally able to complete, its response is returned. The jsii runtime library must respond to each callback request with a complete response, allowing the jsii kernel to resume fulfilling the original request. In order to do this, the jsii runtime library obtains the foreign object corresponding to the callback request 's receiver, then invokes the corresponding implementation (for example, using reflection). When needed, the original JavaScript implementation can be delegated to (many languages refer to this as super(...) or some similar idiom).","title":"Invoking Overrides"},{"location":"user-guides/language-support/callbacks/#example","text":"Assuming we have the following TypeScript types defined: export abstract class FooClass { protected abstract baz : string ; public bar () : string { return this . reverse () ? Array . from ( this . baz ). reverse (). join ( '' ) : this . baz ; } protected reverse () : boolean { return false ; } } And we have the following Foreign application (assuming Java ): public final class Main extends FooClass { public static final void main ( final String [] args ) { final FooClass self = new Main (); System . out . println ( self . bar ()); } @Override public String getBaz () { return \"baz\" ; } @Override public boolean reverse () { return true ; } } The schematized exchange between the jsii runtime library and the jsii kernel is the following: \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u250f\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513 \u2503 Kernel \u2503 \u2503Runtime Library\u2503 \u2517\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u251b \u2517\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u251b \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u25c0\u2500\u2524 Create(FQN: \"FooClass\", Overrides=[\"baz\", \"reverse\"]) \u251c\u2500\u2500\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 OK(ObjID: \"Foo\") \u251c\u2500\u25b6\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u25c0\u2500\u2524 InvokeRequest(ObjID: \"Foo\", Method: \"bar\") \u251c\u2500\u2500\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 CallbackRequest(ID: 1, ObjID: \"Foo\", Invoke: \"reverse\") \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2502call \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2502obj(\"Foo\").reverse() \u2503\u25c0\u2500\u2524 Complete(CallbackID: 1, OK: true) \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 CallbackRequest(ID: 2, ObjID: \"Foo\", Get: \"baz\") \u251c\u2500\u25b6\u2503\u2500\u2500\u2500\u2500\u2510 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2502get \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2502obj(\"Foo\").baz \u2503\u25c0\u2500\u2524 Complete(CallbackID: 2, OK: \"baz\") \u251c\u2500\u2500\u2503\u25c0\u2500\u2500\u2500\u2518 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2503 \u2503\u2500\u2500\u2524 InvokeResponse(OK: \"zab\") \u251c\u2500\u25b6\u2503 \u2503 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u2503 \u2503 \u2503","title":"Example"},{"location":"user-guides/language-support/callbacks/#see-also","text":"The jsii runtime architecture The jsii kernel API","title":"See Also"},{"location":"user-guides/lib-author/","text":"Prerequisites Common Runtime Whether you are developing jsii modules or consuming them (see Runtime Architecture ), a compatible node runtime must be available. Current node runtime versions support status is as follows: The following node releases are part of our test matrix: Release Status End-of-Life ^14.6.0 Supported 2023-04-30 ^16.3.0 Supported 2024-04-30 ^18.0.0 Supported 2025-04-30 Status Definitions Supported : Long Term Support (LTS) releases (those with an even major version) are supported and bugs specific to those releases are addressed with the highest priority. Every jsii release is automatically tested against those releases. Best effort : Development releases (those with an odd major version) are supported on a best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors that we may not be able to fix. Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release. The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each). Other Languages When developing jsii modules , the SDK for each desired target language must be available for jsii-pacmak to be able to produce releasable artifacts. Language/Platform SDK Requirement .NET .NET Core \u2265 3.1 / .NET \u2265 5.0 Go Go \u2265 1.18 Java JDK \u2265 8 and Maven \u2265 3.6 Python Python \u2265 3.7 Download Locations This table provides typical download locations for the prerequisites mentioned in this document. Most of these tools can also be installed using traditional package managers (standard for the operating system and platform). Tool Description Location .NET Official Microsoft .NET SDK distribution Download Amazon Corretto Amazon's free OpenJDK distribution Download Go Official Go distribution Download OpenJDK Oracle OpenJDK distribution Download Maven Official Maven distribution Download Node Official NodeJS distribution Download","title":"Prerequisites"},{"location":"user-guides/lib-author/#prerequisites","text":"","title":"Prerequisites"},{"location":"user-guides/lib-author/#common-runtime","text":"Whether you are developing jsii modules or consuming them (see Runtime Architecture ), a compatible node runtime must be available. Current node runtime versions support status is as follows: The following node releases are part of our test matrix: Release Status End-of-Life ^14.6.0 Supported 2023-04-30 ^16.3.0 Supported 2024-04-30 ^18.0.0 Supported 2025-04-30 Status Definitions Supported : Long Term Support (LTS) releases (those with an even major version) are supported and bugs specific to those releases are addressed with the highest priority. Every jsii release is automatically tested against those releases. Best effort : Development releases (those with an odd major version) are supported on a best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors that we may not be able to fix. Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release. The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each).","title":" Common Runtime"},{"location":"user-guides/lib-author/#other-languages","text":"When developing jsii modules , the SDK for each desired target language must be available for jsii-pacmak to be able to produce releasable artifacts. Language/Platform SDK Requirement .NET .NET Core \u2265 3.1 / .NET \u2265 5.0 Go Go \u2265 1.18 Java JDK \u2265 8 and Maven \u2265 3.6 Python Python \u2265 3.7","title":" Other Languages"},{"location":"user-guides/lib-author/#download-locations","text":"This table provides typical download locations for the prerequisites mentioned in this document. Most of these tools can also be installed using traditional package managers (standard for the operating system and platform). Tool Description Location .NET Official Microsoft .NET SDK distribution Download Amazon Corretto Amazon's free OpenJDK distribution Download Go Official Go distribution Download OpenJDK Oracle OpenJDK distribution Download Maven Official Maven distribution Download Node Official NodeJS distribution Download","title":" Download Locations"},{"location":"user-guides/lib-author/hints/","text":"Type system hints The jsii compiler interprets some documentation tags as hints that influence the type system represented in the .jsii assembly files. Forcing an interface to be considered a struct Using the @struct tag, an interface will be interpreted as a struct even if its name starts with a capital I , followed by another capital letter (which normally would make them be treated as behavioral interfaces ): /** * @struct */ export interface IPRange { readonly cidr : string : } Important The @struct hint can only be used on interface declarations. Attempting to use them on any other declaration will result in a compilation error.","title":"Type system hints"},{"location":"user-guides/lib-author/hints/#type-system-hints","text":"The jsii compiler interprets some documentation tags as hints that influence the type system represented in the .jsii assembly files.","title":"Type system hints"},{"location":"user-guides/lib-author/hints/#forcing-an-interface-to-be-considered-a-struct","text":"Using the @struct tag, an interface will be interpreted as a struct even if its name starts with a capital I , followed by another capital letter (which normally would make them be treated as behavioral interfaces ): /** * @struct */ export interface IPRange { readonly cidr : string : } Important The @struct hint can only be used on interface declarations. Attempting to use them on any other declaration will result in a compilation error.","title":"Forcing an interface to be considered a struct"},{"location":"user-guides/lib-author/typescript-restrictions/","text":"TypeScript Restrictions Since the API exported by jsii modules will be represented in a variety of other languages, certain restrictions are enforced by the jsii compiler. Info Since those restrictions are solely intended to ensure the exported API can be represented in other languages, they do not apply to any internal declarations such as private members and declarations annotated with the /** @internal */ tag. Dependencies A jsii module can declare dependencies on any other jsii module by adding entries in the dependencies key in the package.json file. Since most other platforms do not support multiple different versions of the same library to coexist in the same closure, it is recommended to also declare all such dependencies as peerDependencies . Occasionally, a dependency on a non-jsii module is useful. Since such dependencies do not have generated bindings in all the supported languages, they must be bundled with the jsii module that depends on them, by adding the library into the bundleDependencies array in package.json . The API of the jsii module can not expose any type from bundled dependencies, since those types would not be available in other languages. Info For more information on package.json file contents, refer to the npm documentation . Naming Class Members Members of classes cannot share the same PascalCased representation as the declaring class itself, as this results in invalid C# code: export class Foo { // \ud83d\udca5 Illegal property name public foo : string ; } export class Bar { // \ud83d\udca5 Illegal method name public bar () : void { /* ... */ } } Danger Due to existing usage, this restriction is only enforced when jsii is invoked with the --strict option. The generated C# class name will receive a _ suffix if any of it's members conflict, which is a breaking change to existing .NET consumers when a conflicting member is introduced after the initial release. Interfaces The jsii type model distinguishes two kinds of interfaces : Behavioral interfaces , which can declare methods and properties Structs , which are immutable pure data entities, and can consequently only declare readonly properties A name convention is used to distinguish between these two: behavioral interfaces must have a name that starts with a I prefix, while structs must not have such a prefix. Info The /** @struct */ type system hint can be used to force an interface with a name starting with the I prefix to be handled as a struct instead of a behavioral interface . /** * Since there is no `I` prefix, Foo is considered to be a struct. */ export interface Foo { // \ud83d\udca5 Structs are not allowed to declare methods foo () : void ; // \ud83d\udca5 Structs are not allowed to declare mutable properties mutableProperty : number ; // \u2705 Structs can declare immutable properties readonly immutableProperty : string ; } /** * Since there is an `I` prefix, IFoo is considered to be a behavioral interface. */ export interface IFoo { // \u2705 Behavioral interfaces can declare methods foo () : void ; // \u2705 Behavioral interfaces can declare mutable properties mutableProperty : number ; // \u2705 Behavioral interfaces can declare immutable properties readonly immutableProperty : string ; } Inheritance Structs As structs are pure data entities, they can only be extended by other structs : export interface Struct { /* ...readonly properties... */ } // \ud83d\udca5 Structs cannot be extended by behavioral interfaces export interface IBehavioralInterface extends Struct { /* ... */ } // \ud83d\udca5 Structs cannot be implemented by classes export class ConcreteType implements Struct { /* ... */ } // \u2705 Structs can extend other structs export interface SuperStruct extends Struct { /* ...readonly properties */ } Member Visibility The C# language does not allow overriding members to change the visibility of the overridden declaration, even if the updated visibility is more permissive. As a consequence, overridden members are required to retain the same visibility as their parents. Danger This makes changing the visibility of a protected member to public is a breaking change in jsii libraries! export class Base { protected method () : void { /* ... */ } } export class Subclass extends Base { // \ud83d\udca5 Illegal change of visibility from protected to public public method () : void { /* ... */ } } Covariant Overrides & Parameter List Changes In TypeScript , overriding members can have a signature that differs from the overridden member as long as the new signature is compatible with the parent. This is however not supported as: Java and C# do not support omitting parameters when overriding or implementing a member C# does not support overriding or implementing a member using covariant parameter or return types Note C# 9 introduces support for covariant return types, which would allow relaxing this restriction, however jsii must build code targetting the .NET Core 3.1 runtime, which only supports C# 8 . Once .NET Core 3.1 becimes end-of-life, this may change. export class Base { public method ( param : any ) : any { /* ... */ } } export class Child extends Base { // \ud83d\udca5 Parameter signatures do not match public method () : any { /* ... */ } // \ud83d\udca5 Parameter types do not match, even though they are covariant public method ( param : string ) : any { /* ... */ } // \ud83d\udca5 Return type does not match, even though it is covariant public method ( param : any ) : string { /* ... */ } } Parameterized Types (aka: Generics) Parameterized types are not consistently supported in all supported target languages. Go does not currently support generics, and the differences in generic semantics between TypeScript , C# and Java make it difficult to correctly represent such types in all those languages. As a consequence, jsii does not support declaring parameterized types. Only certain built-in parameterized types can be used in jsii modules: Array<T> , which is equivalent to T[] Record<string, T> , which is equivalent to { [key: string]: T } Promise<T> , which is the return type of any asynchronous method // \ud83d\udca5 Parameterized types cannot be introduced export interface Parameterized < T > { readonly value : T ; } export interface IAsyncFooMaker { // \u2705 Asynchronous methods must return promises makeFoo () : Promise < Foo > ; // \u2705 Arrays are supported makeFoos ( count : number ) : Array < Promise < Foo >> ; } Soft-Reserved Words In order to guarantee a consistent developer experience across all supported languages, jsii emits warnings whenever a declaration is named after any target language's reserved words , as those will need renaming in target languages: C# Java Python Go abstract abstract False break base assert None case bool boolean True chan byte byte and const char char assert continue checked double def default decimal final del defer delegate float elif else double goto except fallthrough event int from for explicit long global func extern native is go fixed short lambda goto float strictfp nonlocal if foreach synchronized not import goto throws or interface implicit transient pass map int volatile raise package internal range is return lock select long struct namespace switch object type operator var out override params readonly ref sbyte sealed short sizeof stackalloc string struct uint ulong unchecked unsafe ushort using virtual volatile Info The list of reserved words is derived from jsii/lib/reserved-words.ts .","title":"TypeScript Restrictions"},{"location":"user-guides/lib-author/typescript-restrictions/#typescript-restrictions","text":"Since the API exported by jsii modules will be represented in a variety of other languages, certain restrictions are enforced by the jsii compiler. Info Since those restrictions are solely intended to ensure the exported API can be represented in other languages, they do not apply to any internal declarations such as private members and declarations annotated with the /** @internal */ tag.","title":"TypeScript Restrictions"},{"location":"user-guides/lib-author/typescript-restrictions/#dependencies","text":"A jsii module can declare dependencies on any other jsii module by adding entries in the dependencies key in the package.json file. Since most other platforms do not support multiple different versions of the same library to coexist in the same closure, it is recommended to also declare all such dependencies as peerDependencies . Occasionally, a dependency on a non-jsii module is useful. Since such dependencies do not have generated bindings in all the supported languages, they must be bundled with the jsii module that depends on them, by adding the library into the bundleDependencies array in package.json . The API of the jsii module can not expose any type from bundled dependencies, since those types would not be available in other languages. Info For more information on package.json file contents, refer to the npm documentation .","title":"Dependencies"},{"location":"user-guides/lib-author/typescript-restrictions/#naming","text":"","title":"Naming"},{"location":"user-guides/lib-author/typescript-restrictions/#class-members","text":"Members of classes cannot share the same PascalCased representation as the declaring class itself, as this results in invalid C# code: export class Foo { // \ud83d\udca5 Illegal property name public foo : string ; } export class Bar { // \ud83d\udca5 Illegal method name public bar () : void { /* ... */ } } Danger Due to existing usage, this restriction is only enforced when jsii is invoked with the --strict option. The generated C# class name will receive a _ suffix if any of it's members conflict, which is a breaking change to existing .NET consumers when a conflicting member is introduced after the initial release.","title":"Class Members"},{"location":"user-guides/lib-author/typescript-restrictions/#interfaces","text":"The jsii type model distinguishes two kinds of interfaces : Behavioral interfaces , which can declare methods and properties Structs , which are immutable pure data entities, and can consequently only declare readonly properties A name convention is used to distinguish between these two: behavioral interfaces must have a name that starts with a I prefix, while structs must not have such a prefix. Info The /** @struct */ type system hint can be used to force an interface with a name starting with the I prefix to be handled as a struct instead of a behavioral interface . /** * Since there is no `I` prefix, Foo is considered to be a struct. */ export interface Foo { // \ud83d\udca5 Structs are not allowed to declare methods foo () : void ; // \ud83d\udca5 Structs are not allowed to declare mutable properties mutableProperty : number ; // \u2705 Structs can declare immutable properties readonly immutableProperty : string ; } /** * Since there is an `I` prefix, IFoo is considered to be a behavioral interface. */ export interface IFoo { // \u2705 Behavioral interfaces can declare methods foo () : void ; // \u2705 Behavioral interfaces can declare mutable properties mutableProperty : number ; // \u2705 Behavioral interfaces can declare immutable properties readonly immutableProperty : string ; }","title":"Interfaces"},{"location":"user-guides/lib-author/typescript-restrictions/#inheritance","text":"","title":"Inheritance"},{"location":"user-guides/lib-author/typescript-restrictions/#structs","text":"As structs are pure data entities, they can only be extended by other structs : export interface Struct { /* ...readonly properties... */ } // \ud83d\udca5 Structs cannot be extended by behavioral interfaces export interface IBehavioralInterface extends Struct { /* ... */ } // \ud83d\udca5 Structs cannot be implemented by classes export class ConcreteType implements Struct { /* ... */ } // \u2705 Structs can extend other structs export interface SuperStruct extends Struct { /* ...readonly properties */ }","title":"Structs"},{"location":"user-guides/lib-author/typescript-restrictions/#member-visibility","text":"The C# language does not allow overriding members to change the visibility of the overridden declaration, even if the updated visibility is more permissive. As a consequence, overridden members are required to retain the same visibility as their parents. Danger This makes changing the visibility of a protected member to public is a breaking change in jsii libraries! export class Base { protected method () : void { /* ... */ } } export class Subclass extends Base { // \ud83d\udca5 Illegal change of visibility from protected to public public method () : void { /* ... */ } }","title":"Member Visibility"},{"location":"user-guides/lib-author/typescript-restrictions/#covariant-overrides-parameter-list-changes","text":"In TypeScript , overriding members can have a signature that differs from the overridden member as long as the new signature is compatible with the parent. This is however not supported as: Java and C# do not support omitting parameters when overriding or implementing a member C# does not support overriding or implementing a member using covariant parameter or return types Note C# 9 introduces support for covariant return types, which would allow relaxing this restriction, however jsii must build code targetting the .NET Core 3.1 runtime, which only supports C# 8 . Once .NET Core 3.1 becimes end-of-life, this may change. export class Base { public method ( param : any ) : any { /* ... */ } } export class Child extends Base { // \ud83d\udca5 Parameter signatures do not match public method () : any { /* ... */ } // \ud83d\udca5 Parameter types do not match, even though they are covariant public method ( param : string ) : any { /* ... */ } // \ud83d\udca5 Return type does not match, even though it is covariant public method ( param : any ) : string { /* ... */ } }","title":"Covariant Overrides &amp; Parameter List Changes"},{"location":"user-guides/lib-author/typescript-restrictions/#parameterized-types-aka-generics","text":"Parameterized types are not consistently supported in all supported target languages. Go does not currently support generics, and the differences in generic semantics between TypeScript , C# and Java make it difficult to correctly represent such types in all those languages. As a consequence, jsii does not support declaring parameterized types. Only certain built-in parameterized types can be used in jsii modules: Array<T> , which is equivalent to T[] Record<string, T> , which is equivalent to { [key: string]: T } Promise<T> , which is the return type of any asynchronous method // \ud83d\udca5 Parameterized types cannot be introduced export interface Parameterized < T > { readonly value : T ; } export interface IAsyncFooMaker { // \u2705 Asynchronous methods must return promises makeFoo () : Promise < Foo > ; // \u2705 Arrays are supported makeFoos ( count : number ) : Array < Promise < Foo >> ; }","title":"Parameterized Types (aka: Generics)"},{"location":"user-guides/lib-author/typescript-restrictions/#soft-reserved-words","text":"In order to guarantee a consistent developer experience across all supported languages, jsii emits warnings whenever a declaration is named after any target language's reserved words , as those will need renaming in target languages: C# Java Python Go abstract abstract False break base assert None case bool boolean True chan byte byte and const char char assert continue checked double def default decimal final del defer delegate float elif else double goto except fallthrough event int from for explicit long global func extern native is go fixed short lambda goto float strictfp nonlocal if foreach synchronized not import goto throws or interface implicit transient pass map int volatile raise package internal range is return lock select long struct namespace switch object type operator var out override params readonly ref sbyte sealed short sizeof stackalloc string struct uint ulong unchecked unsafe ushort using virtual volatile Info The list of reserved words is derived from jsii/lib/reserved-words.ts .","title":"Soft-Reserved Words"},{"location":"user-guides/lib-author/configuration/","text":"Overview The configuration for jsii is recorded in the package.json file, which is the standard package manifest for NPM packages. This document describes the constraints and extensions jsii adds to the package.json schema . jsii-config Use jsii-config to aid in configuring a new jsii module. Additional Requirements & Extensions In order to be able to generate valid packages for all the supported target package managers, certain fields that are optional in the standard package.json schema are required by jsii . For example, Maven Central requires packages to carry sufficient metadata , such as developer information and license , in order to be valid for publishing. Field Required Extensions author author.organization license main repository stability The field itself is an extension types Attribution & Licensing The author field must be set. Although the string form ( \"The Octocat <octocat@github.com> (https://github.com/octocat)\" ) works, it is recommended to set the value using the object format: { // ... \"author\" : { \"name\" : \"The Octocat\" , // Required \"email\" : \"octocat@github.com\" , // Optional \"url\" : \"https://github.com/octocat\" , // Optional \"organization\" : false // Optional (defaults to false) }, // ... } The organization field is an extension from the package.json schema that can be used to signal the author field refers to an organization and not and individual person. The license field must be set to a valid SPDX license id . If you do not intend to release your package for third-party consumption, UNLICENSED (not to be confused with Unlicense ) is a valid option. Important License Information You are free to decide which license you want to distribute your code under. The bindings generated by jsii-pacmak will use the exact same license as the source TypeScript library they were based on. You are responsible for correctly applying your chosen license to your work (most licenses have documentations outlining how to correctly apply the license), and for complying with the terms of the licenses of packages your work depends on (this is particularly important when dependencies are bundled, as discussed later in this section). In addition to the license field present in the package.json file, we strongly recommend adding a LICENSE file in the package's root directory which contains the standardized text for the license (those can be found on the SPDX website ). Danger Unless you know exactly what you are doing, you should copy the license text verbatim in the LICENSE file. Many organizations have license scanners that will only recognize the standard license text, and editing that may cause undesired friction before users in those organizations can use your library, and may void your license choice. A NOTICE file is often desirable. In particular, if you are developing the library as part of your employment, you should ask your employer's legal team (or equivalent) for specific instructions. Danger If your library includes bundled dependencies (via the bundledDependencies / bundleDependencies key in the package.json file), you are required to comply with those dependencies' licenses provisions pertaining to re-distribution. This often means providing attribution to these in your NOTICE file, among other requirements. The LICENSE and NOTICE files, when present, will be copied into generated binding's source code. If no LICENSE file exists in the source package, the standard SPDX license text will be produced into a LICENSE file in generated bindings whenever possible. Source Control Information The repository field must be set to the URL of the source-control system (such as a git repository) for the package. The recommended way to provide the value is using the object representation: { \"repository\" : { \"url\" : \"https://github.com/aws/jsii.git\" , // Required \"type\" : \"git\" , // Recommended \"directory\" : \"/path\" // Optional } } Library Entry Point Both the main field must be set to the .js file that acts as the entry point of your library (what node's require('library-name') will load). Additionally, TypeScript 's types field must be set to the .d.ts file corresponding to the main file. The assembly emitted by jsii will only represent types that are exported from the types file. Package-level API Stability The .jsii assembly document allows representing API stability levels on individual API elements. The default value set for API elements for which a stability declaration is not found can be configured using the stability field of the package.json file. It can be set to one of the following values: experimental , stable , deprecated and external . While the exact semantic value of those fields is defined by the package maintainer, the generic interpretation for those on packages is: experimental - the package is not yet ready for production usage, as it is still in the early stages of its development. stable - the package is ready for production and its APIs should be expected to adhere to semantic versioning . deprecated - the package should no longer be used and may no longer be maintained. It is a good practice to set the deprecated field in package.json with an explanation of how consumers of the package should update their dependencies. external - the package includes APIs that are derived from external artifacts, and the owners of those artifacts control their stability. The jsii section In order to configure the behavior of jsii , the package.json file must include a jsii section that can contain the following entries: Field Type Required Default excludeTypescript string [] none metadata object none projectReferences boolean true targets object tsc object { outDir : '.' , rootDir : '.' } versionFormat 'short' | 'full' 'full' excludeTypescript By default, jsii will include all *.ts files (except .d.ts files) in the TypeScript compiler input. This can be problematic for example when the package's build or test procedure generates .ts files that cannot be compiled with jsii 's compiler settings. The excludeTypescript configuration accepts a list of glob patterns. Files matching any of those patterns will be excluded from the TypeScript compiler input. metadata The metadata section can be used to record additional metadata as key-value pairs that will be recorded as-is into the .jsii assembly file. That metadata can later be inspected using jsii-reflect utilities, for example. targets The targets section is where jsii packages define which target languages they support. This provides the package generators with the additional information they require in order to name generated artifacts. Configuration is provided as a mapping from target name to a configuration object. The specific configuration accepted for each supported language is presented in dedicated pages: .NET Target Go Target Java Target Python Target tsc In order to the generated javascript can be properly loaded by the jsii runtimes, jsii generates a [ tsconfig.json ] file with fixed settings at the beginning of the compilation pass. Certain configuration options can however be set by the maintainers in order to better suit their development workflow or processes. Those configuration are set in the jsii.tsc section of the package.json file, but use the same name as [ tsconfig.json ]: outDir - path to the directory when artifacts generated by the TypeScript compiler will be placed. This influences the location of .d.ts and .js files, but will not affect the location of the .jsii file, which will always be placed at the package's root. rootDir - specifies the root directory that contains all of the .ts source files. This is used in conjunction with outDir , to control the directory structure that gets generated. forceConsistentCasingInFileNames - if true , will make the TypeScript compiler care about the casing of files specified in import statements. This is helpful if you're developing on a filesystem that is case-insensitive (Mac/Win), but building/deploying on a filesystem that is case-sensitive (Linux). declarationMap , inlineSourceMap , inlineSources , and sourceMap allow confifuring the source map generation. This option can be useful to finely control your local development experience (for example, by enabling declarationMap ), or to optimize the emitted code size (by disabling source maps entirely). if any of these options is specified, the source map configuration will exactly match what is being provided here If none are specified, the default settings will be used: { inlineSourceMap : true , inlineSources : true } types allows limiting which visible type libraries get loaded in the global scope by the typescript compiler. By default, all visible @types/* packages will be loaded, which can be undesirable (in particular in monorepos, where some type libraries are not compatible with the TypeScript compiler version that jsii uses). The value specified here will be forwarded as-is to the TypeScript compiler. baseUrl and paths can be used to configure TypeScript path mappings, and are copied verbatim to tsconfig.json . Refer to the TypeScript compiler options reference for more information about those options. versionFormat Determines the format of the jsii toolchain version string that will be included in the .jsii assembly file's jsiiVersion attribute. full (the default) - a version number including a commit hash will be used For example: 0.14.3 (build 1b1062d) short - only the version number of jsii will be used For example: 0.14.3 This option is primarily useful for developing regression tests when developing jsii itself, as using the short format reduces volatility in the assemblies generated by development versions of jsii . Users of jsii are advised to leave the default setting, as having full version information can be essential when trying to troubleshoot assembly generation problems. Diagnostics JSII produces a number of diagnostic information. These have been categorized into \"error\", \"warning\", \"suggestion\" and \"message\", by default. Diagnostics categorized as \"error\" will fail the jsii compiler and the rest will be printed to console. These can be re-configured to a different category under the diagnostics key as so - \"jsii\" : { // ... \"diagnostics\" : { \"documentation/non-existent-parameter\" : \"error\" , \"code-style/submodule-name-casing\" : \"suggestion\" , \"JSII9998\" : \"error\" , \"JSII9001\" : \"warning\" } } As noted in the example above, the diagnostic code can be the human readable string, or the numeric code prefixed with JSII . The full list of diagnostic codes can be found in jsii-diagnostic.ts . Dependency considerations Like any node library, jsii packages can declare runtime dependencies using the dependencies section of package.json . Dependencies that are jsii modules Node modules are conventionally versioned using semantic versioning , but that is not true of all package managers that jsii is able to target. Additionally, only one version of the jsii runtime and kernel can be used within a given application. In order to avoid version resolution surprises at run-time, jsii requires duplicating jsii modules declarations from dependencies into the peerDependencies section. Dependencies that are not jsii modules The jsii runtimes in non- javascript languages do not use npm install , and as a consequence cannot rely on npm install bringing in a package's dependencies. As a consequence, dependencies that are not themselves jsii modules, must also be referenced in the bundledDependencies section, so that they are bundled within the NPM package.","title":"Overview"},{"location":"user-guides/lib-author/configuration/#overview","text":"The configuration for jsii is recorded in the package.json file, which is the standard package manifest for NPM packages. This document describes the constraints and extensions jsii adds to the package.json schema .","title":"Overview"},{"location":"user-guides/lib-author/configuration/#jsii-config","text":"Use jsii-config to aid in configuring a new jsii module.","title":"jsii-config"},{"location":"user-guides/lib-author/configuration/#additional-requirements-extensions","text":"In order to be able to generate valid packages for all the supported target package managers, certain fields that are optional in the standard package.json schema are required by jsii . For example, Maven Central requires packages to carry sufficient metadata , such as developer information and license , in order to be valid for publishing. Field Required Extensions author author.organization license main repository stability The field itself is an extension types","title":"Additional Requirements &amp; Extensions"},{"location":"user-guides/lib-author/configuration/#attribution-licensing","text":"The author field must be set. Although the string form ( \"The Octocat <octocat@github.com> (https://github.com/octocat)\" ) works, it is recommended to set the value using the object format: { // ... \"author\" : { \"name\" : \"The Octocat\" , // Required \"email\" : \"octocat@github.com\" , // Optional \"url\" : \"https://github.com/octocat\" , // Optional \"organization\" : false // Optional (defaults to false) }, // ... } The organization field is an extension from the package.json schema that can be used to signal the author field refers to an organization and not and individual person. The license field must be set to a valid SPDX license id . If you do not intend to release your package for third-party consumption, UNLICENSED (not to be confused with Unlicense ) is a valid option.","title":"Attribution &amp; Licensing"},{"location":"user-guides/lib-author/configuration/#important-license-information","text":"You are free to decide which license you want to distribute your code under. The bindings generated by jsii-pacmak will use the exact same license as the source TypeScript library they were based on. You are responsible for correctly applying your chosen license to your work (most licenses have documentations outlining how to correctly apply the license), and for complying with the terms of the licenses of packages your work depends on (this is particularly important when dependencies are bundled, as discussed later in this section). In addition to the license field present in the package.json file, we strongly recommend adding a LICENSE file in the package's root directory which contains the standardized text for the license (those can be found on the SPDX website ). Danger Unless you know exactly what you are doing, you should copy the license text verbatim in the LICENSE file. Many organizations have license scanners that will only recognize the standard license text, and editing that may cause undesired friction before users in those organizations can use your library, and may void your license choice. A NOTICE file is often desirable. In particular, if you are developing the library as part of your employment, you should ask your employer's legal team (or equivalent) for specific instructions. Danger If your library includes bundled dependencies (via the bundledDependencies / bundleDependencies key in the package.json file), you are required to comply with those dependencies' licenses provisions pertaining to re-distribution. This often means providing attribution to these in your NOTICE file, among other requirements. The LICENSE and NOTICE files, when present, will be copied into generated binding's source code. If no LICENSE file exists in the source package, the standard SPDX license text will be produced into a LICENSE file in generated bindings whenever possible.","title":"Important License Information"},{"location":"user-guides/lib-author/configuration/#source-control-information","text":"The repository field must be set to the URL of the source-control system (such as a git repository) for the package. The recommended way to provide the value is using the object representation: { \"repository\" : { \"url\" : \"https://github.com/aws/jsii.git\" , // Required \"type\" : \"git\" , // Recommended \"directory\" : \"/path\" // Optional } }","title":"Source Control Information"},{"location":"user-guides/lib-author/configuration/#library-entry-point","text":"Both the main field must be set to the .js file that acts as the entry point of your library (what node's require('library-name') will load). Additionally, TypeScript 's types field must be set to the .d.ts file corresponding to the main file. The assembly emitted by jsii will only represent types that are exported from the types file.","title":"Library Entry Point"},{"location":"user-guides/lib-author/configuration/#package-level-api-stability","text":"The .jsii assembly document allows representing API stability levels on individual API elements. The default value set for API elements for which a stability declaration is not found can be configured using the stability field of the package.json file. It can be set to one of the following values: experimental , stable , deprecated and external . While the exact semantic value of those fields is defined by the package maintainer, the generic interpretation for those on packages is: experimental - the package is not yet ready for production usage, as it is still in the early stages of its development. stable - the package is ready for production and its APIs should be expected to adhere to semantic versioning . deprecated - the package should no longer be used and may no longer be maintained. It is a good practice to set the deprecated field in package.json with an explanation of how consumers of the package should update their dependencies. external - the package includes APIs that are derived from external artifacts, and the owners of those artifacts control their stability.","title":"Package-level API Stability"},{"location":"user-guides/lib-author/configuration/#the-jsii-section","text":"In order to configure the behavior of jsii , the package.json file must include a jsii section that can contain the following entries: Field Type Required Default excludeTypescript string [] none metadata object none projectReferences boolean true targets object tsc object { outDir : '.' , rootDir : '.' } versionFormat 'short' | 'full' 'full'","title":"The jsii section"},{"location":"user-guides/lib-author/configuration/#excludetypescript","text":"By default, jsii will include all *.ts files (except .d.ts files) in the TypeScript compiler input. This can be problematic for example when the package's build or test procedure generates .ts files that cannot be compiled with jsii 's compiler settings. The excludeTypescript configuration accepts a list of glob patterns. Files matching any of those patterns will be excluded from the TypeScript compiler input.","title":"excludeTypescript"},{"location":"user-guides/lib-author/configuration/#metadata","text":"The metadata section can be used to record additional metadata as key-value pairs that will be recorded as-is into the .jsii assembly file. That metadata can later be inspected using jsii-reflect utilities, for example.","title":"metadata"},{"location":"user-guides/lib-author/configuration/#targets","text":"The targets section is where jsii packages define which target languages they support. This provides the package generators with the additional information they require in order to name generated artifacts. Configuration is provided as a mapping from target name to a configuration object. The specific configuration accepted for each supported language is presented in dedicated pages: .NET Target Go Target Java Target Python Target","title":"targets"},{"location":"user-guides/lib-author/configuration/#tsc","text":"In order to the generated javascript can be properly loaded by the jsii runtimes, jsii generates a [ tsconfig.json ] file with fixed settings at the beginning of the compilation pass. Certain configuration options can however be set by the maintainers in order to better suit their development workflow or processes. Those configuration are set in the jsii.tsc section of the package.json file, but use the same name as [ tsconfig.json ]: outDir - path to the directory when artifacts generated by the TypeScript compiler will be placed. This influences the location of .d.ts and .js files, but will not affect the location of the .jsii file, which will always be placed at the package's root. rootDir - specifies the root directory that contains all of the .ts source files. This is used in conjunction with outDir , to control the directory structure that gets generated. forceConsistentCasingInFileNames - if true , will make the TypeScript compiler care about the casing of files specified in import statements. This is helpful if you're developing on a filesystem that is case-insensitive (Mac/Win), but building/deploying on a filesystem that is case-sensitive (Linux). declarationMap , inlineSourceMap , inlineSources , and sourceMap allow confifuring the source map generation. This option can be useful to finely control your local development experience (for example, by enabling declarationMap ), or to optimize the emitted code size (by disabling source maps entirely). if any of these options is specified, the source map configuration will exactly match what is being provided here If none are specified, the default settings will be used: { inlineSourceMap : true , inlineSources : true } types allows limiting which visible type libraries get loaded in the global scope by the typescript compiler. By default, all visible @types/* packages will be loaded, which can be undesirable (in particular in monorepos, where some type libraries are not compatible with the TypeScript compiler version that jsii uses). The value specified here will be forwarded as-is to the TypeScript compiler. baseUrl and paths can be used to configure TypeScript path mappings, and are copied verbatim to tsconfig.json . Refer to the TypeScript compiler options reference for more information about those options.","title":"tsc"},{"location":"user-guides/lib-author/configuration/#versionformat","text":"Determines the format of the jsii toolchain version string that will be included in the .jsii assembly file's jsiiVersion attribute. full (the default) - a version number including a commit hash will be used For example: 0.14.3 (build 1b1062d) short - only the version number of jsii will be used For example: 0.14.3 This option is primarily useful for developing regression tests when developing jsii itself, as using the short format reduces volatility in the assemblies generated by development versions of jsii . Users of jsii are advised to leave the default setting, as having full version information can be essential when trying to troubleshoot assembly generation problems.","title":"versionFormat"},{"location":"user-guides/lib-author/configuration/#diagnostics","text":"JSII produces a number of diagnostic information. These have been categorized into \"error\", \"warning\", \"suggestion\" and \"message\", by default. Diagnostics categorized as \"error\" will fail the jsii compiler and the rest will be printed to console. These can be re-configured to a different category under the diagnostics key as so - \"jsii\" : { // ... \"diagnostics\" : { \"documentation/non-existent-parameter\" : \"error\" , \"code-style/submodule-name-casing\" : \"suggestion\" , \"JSII9998\" : \"error\" , \"JSII9001\" : \"warning\" } } As noted in the example above, the diagnostic code can be the human readable string, or the numeric code prefixed with JSII . The full list of diagnostic codes can be found in jsii-diagnostic.ts .","title":"Diagnostics"},{"location":"user-guides/lib-author/configuration/#dependency-considerations","text":"Like any node library, jsii packages can declare runtime dependencies using the dependencies section of package.json .","title":"Dependency considerations"},{"location":"user-guides/lib-author/configuration/#dependencies-that-are-jsii-modules","text":"Node modules are conventionally versioned using semantic versioning , but that is not true of all package managers that jsii is able to target. Additionally, only one version of the jsii runtime and kernel can be used within a given application. In order to avoid version resolution surprises at run-time, jsii requires duplicating jsii modules declarations from dependencies into the peerDependencies section.","title":"Dependencies that are jsii modules"},{"location":"user-guides/lib-author/configuration/#dependencies-that-are-not-jsii-modules","text":"The jsii runtimes in non- javascript languages do not use npm install , and as a consequence cannot rely on npm install bringing in a package's dependencies. As a consequence, dependencies that are not themselves jsii modules, must also be referenced in the bundledDependencies section, so that they are bundled within the NPM package.","title":"Dependencies that are not jsii modules"},{"location":"user-guides/lib-author/configuration/targets/dotnet/","text":".NET The dotnet target requires the following configuration: namespace - the root namespace under which types will be declared. packageId - the identified of the package in the NuGet registry. iconUrl - the URL of the icon to be shown in the NuGet Gallery . It should be at least 64x64 pixels and a transparent background is recommended. See the .NET documentation for more information. versionSuffix - an optional suffix that will be appended at the end of the NuGet package's version field. The suffix must start with a - . Example: { \"jsii\" : { \"dotnet\" : { \"namespace\" : \"Acme.HelloJsii\" , // Required \"packageId\" : \"Acme.HelloJsii\" , // Required \"iconUrl\" : \"https://cdn.acme.com/icon.png\" , // Optional \"versionSuffix\" : \"-preview\" // Optional }, // ... }, // ... } The resulting artifact is a NuGet package that can be published to NuGet using the standard nuget push command.","title":".NET"},{"location":"user-guides/lib-author/configuration/targets/dotnet/#net","text":"The dotnet target requires the following configuration: namespace - the root namespace under which types will be declared. packageId - the identified of the package in the NuGet registry. iconUrl - the URL of the icon to be shown in the NuGet Gallery . It should be at least 64x64 pixels and a transparent background is recommended. See the .NET documentation for more information. versionSuffix - an optional suffix that will be appended at the end of the NuGet package's version field. The suffix must start with a - . Example: { \"jsii\" : { \"dotnet\" : { \"namespace\" : \"Acme.HelloJsii\" , // Required \"packageId\" : \"Acme.HelloJsii\" , // Required \"iconUrl\" : \"https://cdn.acme.com/icon.png\" , // Optional \"versionSuffix\" : \"-preview\" // Optional }, // ... }, // ... } The resulting artifact is a NuGet package that can be published to NuGet using the standard nuget push command.","title":" .NET"},{"location":"user-guides/lib-author/configuration/targets/go/","text":"Go To enable go package generation, add the go key to the jsii targets configuration: packageName (optional) - The name of the Go package name. If not specified, package name will be derived from the JavaScript module name by removing non-alphanumeric characters (e.g. @aws-cdk/aws-s3 will be awscdkawss3 ). If this is set on a submodule config file ( .jsiirc.json ), it refers to the submodule package name. moduleName (required) - The name of the target repository in which this module will be published (e.g. github.com/foo/bar ). The module itself will always be published under a subdirectory named according to the Go package name of the module (e.g. github.com/foo/bar/awscdk ). versionSuffix (optional) - Can be provided that will be appended at the end of the module version. This will add generated go package code to your specified outDir under go/PACKAGE_NAME (e.g. dist/go/awscdklib ). { \"jsii\" : { \"targets\" : { \"go\" : { \"moduleName\" : \"github.com/foo/bar\" , // REQUIRED \"packageName\" : \"hello\" , // OPTIONAL \"versionSuffix\" : \"-devprefix\" // OPTIONAL }, // ... }, // ... }, // ... }","title":"Go"},{"location":"user-guides/lib-author/configuration/targets/go/#go","text":"To enable go package generation, add the go key to the jsii targets configuration: packageName (optional) - The name of the Go package name. If not specified, package name will be derived from the JavaScript module name by removing non-alphanumeric characters (e.g. @aws-cdk/aws-s3 will be awscdkawss3 ). If this is set on a submodule config file ( .jsiirc.json ), it refers to the submodule package name. moduleName (required) - The name of the target repository in which this module will be published (e.g. github.com/foo/bar ). The module itself will always be published under a subdirectory named according to the Go package name of the module (e.g. github.com/foo/bar/awscdk ). versionSuffix (optional) - Can be provided that will be appended at the end of the module version. This will add generated go package code to your specified outDir under go/PACKAGE_NAME (e.g. dist/go/awscdklib ). { \"jsii\" : { \"targets\" : { \"go\" : { \"moduleName\" : \"github.com/foo/bar\" , // REQUIRED \"packageName\" : \"hello\" , // OPTIONAL \"versionSuffix\" : \"-devprefix\" // OPTIONAL }, // ... }, // ... }, // ... }","title":"Go"},{"location":"user-guides/lib-author/configuration/targets/java/","text":"Java The java target requires the following configuration: maven - the groupId and artifactId for the Maven package. Optionally a versionSuffix can be provided that will be appended at the end of the Maven package's version field. The suffix must start with a . or a - . package - the root Java package name under which the types will be declared. Example: { \"jsii\" : { \"java\" : { \"package\" : \"acme.jsii.hello\" , // Required \"maven\" : { \"groupId\" : \"acme\" , // Required \"artifactId\" : \"jsii-hello\" , // Required \"versionSuffix\" : \".PREVIEW\" // Optional } }, // ... }, // ... } The resulting artifact is a Maven package that can be deployed to Maven Central using the deploy-staged-repository command of the nexus-staging-maven-plugin .","title":"Java"},{"location":"user-guides/lib-author/configuration/targets/java/#java","text":"The java target requires the following configuration: maven - the groupId and artifactId for the Maven package. Optionally a versionSuffix can be provided that will be appended at the end of the Maven package's version field. The suffix must start with a . or a - . package - the root Java package name under which the types will be declared. Example: { \"jsii\" : { \"java\" : { \"package\" : \"acme.jsii.hello\" , // Required \"maven\" : { \"groupId\" : \"acme\" , // Required \"artifactId\" : \"jsii-hello\" , // Required \"versionSuffix\" : \".PREVIEW\" // Optional } }, // ... }, // ... } The resulting artifact is a Maven package that can be deployed to Maven Central using the deploy-staged-repository command of the nexus-staging-maven-plugin .","title":" Java"},{"location":"user-guides/lib-author/configuration/targets/python/","text":"Python The python target requires two configuration entries: module - the name of the generated Python module, which will be used by users in import directives. distName - the PyPI distribution name for the package. classifiers - a list of trove classifiers to declare on the package. It is the user's responsibility to specify valid values (the authoritative list of valid trove classifiers is defined in the pypa/trove-classifiers package). Some classifiers are automatically included (and should not be added to the classifiers property) based on relevant configuration from the package.json file: Development Status :: is determined based on the package's stability License :: is determined based on the package's license Operating System :: OS Independent is always set Typing :: Typed is always set Additionally, the following Programming Language :: classifiers are already set (more could be added by the user if relevant): Programming Language :: Python :: 3 :: Only Programming Language :: Python :: 3.7 Programming Language :: Python :: 3.8 Programming Language :: Python :: 3.9 Programming Language :: Python :: 3.10 Example: { \"jsii\" : { \"targets\" : { \"python\" : { \"module\" : \"hello_jsii\" , // Required \"distName\" : \"hello-jsii\" , // Required \"classifiers\" : [ // Optional \"Framework :: AWS CDK\" , \"Framework :: AWS CDK :: 1\" ] }, // ... } // ... }, // ... } The resulting package can be published to PyPI . Prerelease Versions The original npm package may feature a version number that includes a SemVer 2.0 -compliant prerelease identifer (e.g: 1.2.3-pre.4 ). Python packages distributed to PyPI must however use a different format to express prerelease versions, as specified in PEP-440 . In order to generate valid packages, only certain prerelease identifiers are accepted by jsii-pacmak , and are translated according to the following table: Source Version ( npm ) Python Version ( PEP-440 ) Notes X.Y.Z-dev.N X.Y.Z.devN Development, iteration N . X.Y.Z-pre.N X.Y.Z.devN Development, iteration N X.Y.Z-alpha.N X.Y.Z.aN Alpha release, iteration N X.Y.Z-beta.N X.Y.Z.bN Beta release, iteration N X.Y.Z-rc.N X.Y.Z.rcN Release candidate, iteration N","title":"Python"},{"location":"user-guides/lib-author/configuration/targets/python/#python","text":"The python target requires two configuration entries: module - the name of the generated Python module, which will be used by users in import directives. distName - the PyPI distribution name for the package. classifiers - a list of trove classifiers to declare on the package. It is the user's responsibility to specify valid values (the authoritative list of valid trove classifiers is defined in the pypa/trove-classifiers package). Some classifiers are automatically included (and should not be added to the classifiers property) based on relevant configuration from the package.json file: Development Status :: is determined based on the package's stability License :: is determined based on the package's license Operating System :: OS Independent is always set Typing :: Typed is always set Additionally, the following Programming Language :: classifiers are already set (more could be added by the user if relevant): Programming Language :: Python :: 3 :: Only Programming Language :: Python :: 3.7 Programming Language :: Python :: 3.8 Programming Language :: Python :: 3.9 Programming Language :: Python :: 3.10 Example: { \"jsii\" : { \"targets\" : { \"python\" : { \"module\" : \"hello_jsii\" , // Required \"distName\" : \"hello-jsii\" , // Required \"classifiers\" : [ // Optional \"Framework :: AWS CDK\" , \"Framework :: AWS CDK :: 1\" ] }, // ... } // ... }, // ... } The resulting package can be published to PyPI .","title":" Python"},{"location":"user-guides/lib-author/configuration/targets/python/#prerelease-versions","text":"The original npm package may feature a version number that includes a SemVer 2.0 -compliant prerelease identifer (e.g: 1.2.3-pre.4 ). Python packages distributed to PyPI must however use a different format to express prerelease versions, as specified in PEP-440 . In order to generate valid packages, only certain prerelease identifiers are accepted by jsii-pacmak , and are translated according to the following table: Source Version ( npm ) Python Version ( PEP-440 ) Notes X.Y.Z-dev.N X.Y.Z.devN Development, iteration N . X.Y.Z-pre.N X.Y.Z.devN Development, iteration N X.Y.Z-alpha.N X.Y.Z.aN Alpha release, iteration N X.Y.Z-beta.N X.Y.Z.bN Beta release, iteration N X.Y.Z-rc.N X.Y.Z.rcN Release candidate, iteration N","title":"Prerelease Versions"},{"location":"user-guides/lib-author/quick-start/set-up/","text":"Set Up Creating a new npm package Start by creating a new empty npm package: # mkdir project-name # cd project-name # npm init -y Wrote to /Users/rmuller/Downloads/project-name/package.json: { \"name\": \"project-name\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } Adding mandatory metadata Then, add the mandatory information to the new package.json file that was created. Specifically, jsii modules must have an author and repository setting (those are necessary to generate valid libraries for certain distribution points, such as Maven Central ): { \"name\" : \"project-name\" , \"version\" : \"1.0.0\" , \"description\" : \"A demonstration jsii library\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\" : [], \"author\" : { \"name\" : \"John Doe\" , \"email\" : \"john.doe@acme.com\" }, \"repository\" : { \"url\" : \"https://github.com/acme/project-name.git\" }, \"license\" : \"ISC\" } Important Before publishing your work, be sure to review the Important License Information documentation. Setting up the jsii configuration Finish up the configuration by running jsii-config , and letting the assistant guide you through the process: # npx jsii-config ? Target Languages (Press <space> to select, <a> to toggle all, <i> to invert selection) \u276f\u25ef java \u25ef python \u25ef dotnet ... Success! Install Dependencies Now, you're ready to install the basic tools into the packages' dependency closure. The exact instructions depend on the JavaScript package manager you want to be using: yarn # yarn add -D jsii jsii-pacmak yarn add v1.22.10 info No lockfile found. [1/4] \ud83d\udd0d Resolving packages... [2/4] \ud83d\ude9a Fetching packages... [3/4] \ud83d\udd17 Linking dependencies... [4/4] \ud83d\udd28 Building fresh packages... success Saved lockfile. success Saved 66 new dependencies. ... npm # npm install --save-dev jsii jsii-pacmak added 107 packages, and audited 107 packages in 4s 39 packages are looking for funding run `npm fund` for details found 0 vulnerabilities Set up essential scripts Finally, you might want to configure convenience scripts in your package.json file in order to facilitate working with your project: { \"name\" : \"project-name\" , \"version\" : \"1.0.0\" , \"description\" : \"A demonstration jsii library\" , \"main\" : \"index.js\" , \"scripts\" : { \"build\" : \"jsii\" , \"build:watch\" : \"jsii --watch\" , \"package\" : \"jsii-pacmak\" }, \"keywords\" : [] // ... } Those scripts have the following effect: Script Description build Compiles the project build:watch Watches for file changes and recompiles as needed package Generates libraries for all languages","title":"Set Up"},{"location":"user-guides/lib-author/quick-start/set-up/#set-up","text":"","title":"Set Up"},{"location":"user-guides/lib-author/quick-start/set-up/#creating-a-new-npm-package","text":"Start by creating a new empty npm package: # mkdir project-name # cd project-name # npm init -y Wrote to /Users/rmuller/Downloads/project-name/package.json: { \"name\": \"project-name\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" }","title":"Creating a new npm package"},{"location":"user-guides/lib-author/quick-start/set-up/#adding-mandatory-metadata","text":"Then, add the mandatory information to the new package.json file that was created. Specifically, jsii modules must have an author and repository setting (those are necessary to generate valid libraries for certain distribution points, such as Maven Central ): { \"name\" : \"project-name\" , \"version\" : \"1.0.0\" , \"description\" : \"A demonstration jsii library\" , \"main\" : \"index.js\" , \"scripts\" : { \"test\" : \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\" : [], \"author\" : { \"name\" : \"John Doe\" , \"email\" : \"john.doe@acme.com\" }, \"repository\" : { \"url\" : \"https://github.com/acme/project-name.git\" }, \"license\" : \"ISC\" } Important Before publishing your work, be sure to review the Important License Information documentation.","title":"Adding mandatory metadata"},{"location":"user-guides/lib-author/quick-start/set-up/#setting-up-the-jsii-configuration","text":"Finish up the configuration by running jsii-config , and letting the assistant guide you through the process: # npx jsii-config ? Target Languages (Press <space> to select, <a> to toggle all, <i> to invert selection) \u276f\u25ef java \u25ef python \u25ef dotnet ... Success!","title":"Setting up the jsii configuration"},{"location":"user-guides/lib-author/quick-start/set-up/#install-dependencies","text":"Now, you're ready to install the basic tools into the packages' dependency closure. The exact instructions depend on the JavaScript package manager you want to be using: yarn # yarn add -D jsii jsii-pacmak yarn add v1.22.10 info No lockfile found. [1/4] \ud83d\udd0d Resolving packages... [2/4] \ud83d\ude9a Fetching packages... [3/4] \ud83d\udd17 Linking dependencies... [4/4] \ud83d\udd28 Building fresh packages... success Saved lockfile. success Saved 66 new dependencies. ... npm # npm install --save-dev jsii jsii-pacmak added 107 packages, and audited 107 packages in 4s 39 packages are looking for funding run `npm fund` for details found 0 vulnerabilities","title":"Install Dependencies"},{"location":"user-guides/lib-author/quick-start/set-up/#set-up-essential-scripts","text":"Finally, you might want to configure convenience scripts in your package.json file in order to facilitate working with your project: { \"name\" : \"project-name\" , \"version\" : \"1.0.0\" , \"description\" : \"A demonstration jsii library\" , \"main\" : \"index.js\" , \"scripts\" : { \"build\" : \"jsii\" , \"build:watch\" : \"jsii --watch\" , \"package\" : \"jsii-pacmak\" }, \"keywords\" : [] // ... } Those scripts have the following effect: Script Description build Compiles the project build:watch Watches for file changes and recompiles as needed package Generates libraries for all languages","title":"Set up essential scripts"},{"location":"user-guides/lib-author/quick-start/write-code/","text":"Write Code The index.ts content Create a new index.ts file with your initial code: export interface GreeterProps { readonly greetee : string ; } export class Greeter { private readonly greetee : string ; public constructor ( props : GreeterProps ) { this . greetee = props . greetee ; } public greet () : string { return `Hello, ${ this . greetee } !` } } Iterate Either run the build or build:watch script from the Set Up step in order to compile the project. The necessary tsconfig.json is automatically created so the TypeScript compiler produces the correct output. Generate Targets Once you are satisfied with the library, bindings in all supported languages can be generated by running jsii-pacmak , typically by using the package script from the Set Up step. Publishable artifacts will be generated and placed in per-language sub-directories of the dist folder: $ tree dist dist \u251c\u2500\u2500 dotnet \u2502 \u251c\u2500\u2500 Acme.ProjectName.1.0.0.nupkg \u2502 \u2514\u2500\u2500 Acme.ProjectName.1.0.0.snupkg \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 com \u2502 \u2514\u2500\u2500 acme \u2502 \u2514\u2500\u2500 sample \u2502 \u2514\u2500\u2500 project-name \u2502 \u251c\u2500\u2500 1.0.0 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.pom \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.pom.md5 \u2502 \u2502 \u2514\u2500\u2500 project-name-1.0.0.pom.sha1 \u2502 \u251c\u2500\u2500 maven-metadata.xml \u2502 \u251c\u2500\u2500 maven-metadata.xml.md5 \u2502 \u2514\u2500\u2500 maven-metadata.xml.sha1 \u251c\u2500\u2500 js \u2502 \u2514\u2500\u2500 project-name@1.0.0.jsii.tgz \u2514\u2500\u2500 python \u251c\u2500\u2500 project-name-1.0.0.tar.gz \u2514\u2500\u2500 project_name-1.0.0-py3-none-any.whl 9 directories, 20 files","title":"Write Code"},{"location":"user-guides/lib-author/quick-start/write-code/#write-code","text":"","title":"Write Code"},{"location":"user-guides/lib-author/quick-start/write-code/#the-indexts-content","text":"Create a new index.ts file with your initial code: export interface GreeterProps { readonly greetee : string ; } export class Greeter { private readonly greetee : string ; public constructor ( props : GreeterProps ) { this . greetee = props . greetee ; } public greet () : string { return `Hello, ${ this . greetee } !` } }","title":"The index.ts content"},{"location":"user-guides/lib-author/quick-start/write-code/#iterate","text":"Either run the build or build:watch script from the Set Up step in order to compile the project. The necessary tsconfig.json is automatically created so the TypeScript compiler produces the correct output.","title":"Iterate"},{"location":"user-guides/lib-author/quick-start/write-code/#generate-targets","text":"Once you are satisfied with the library, bindings in all supported languages can be generated by running jsii-pacmak , typically by using the package script from the Set Up step. Publishable artifacts will be generated and placed in per-language sub-directories of the dist folder: $ tree dist dist \u251c\u2500\u2500 dotnet \u2502 \u251c\u2500\u2500 Acme.ProjectName.1.0.0.nupkg \u2502 \u2514\u2500\u2500 Acme.ProjectName.1.0.0.snupkg \u251c\u2500\u2500 java \u2502 \u2514\u2500\u2500 com \u2502 \u2514\u2500\u2500 acme \u2502 \u2514\u2500\u2500 sample \u2502 \u2514\u2500\u2500 project-name \u2502 \u251c\u2500\u2500 1.0.0 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-javadoc.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0-sources.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar.md5 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.jar.sha1 \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.pom \u2502 \u2502 \u251c\u2500\u2500 project-name-1.0.0.pom.md5 \u2502 \u2502 \u2514\u2500\u2500 project-name-1.0.0.pom.sha1 \u2502 \u251c\u2500\u2500 maven-metadata.xml \u2502 \u251c\u2500\u2500 maven-metadata.xml.md5 \u2502 \u2514\u2500\u2500 maven-metadata.xml.sha1 \u251c\u2500\u2500 js \u2502 \u2514\u2500\u2500 project-name@1.0.0.jsii.tgz \u2514\u2500\u2500 python \u251c\u2500\u2500 project-name-1.0.0.tar.gz \u2514\u2500\u2500 project_name-1.0.0-py3-none-any.whl 9 directories, 20 files","title":"Generate Targets"},{"location":"user-guides/lib-author/toolchain/jsii/","text":"jsii The jsii tool wraps the standard TypeScript compiler, applies the TypeScript restrictions , producing additional diagnostic messages as necessary. Options Info This section discusses the main options of jsii only. There may be additional options not mentioned on this page, which can learn about using jsii --help . --watch The --watch option behaves similar to that of the standard TypeScript compiler. It will make jsii listen to file changes within the project, and recompile whenever a source file has changed (including producing diagnostic messages, and a new .jsii assembly file as needed). This option is useful when iterating on your code, as it provides a faster feedback loop than periodically manually re-compiling. --project-references When --project-references is specified, jsii will generate a tsconfig.json file that includes references to any other local jsii project present in the dependency closure of the current one. This option is recommended for any project that is part of a mono-repository, where multiple jsii packages are being maintained. It can result in improved build times, and a better IDE experience. --fail-on-warnings The --fail-on-warnings option causes compilation top fail if any warning diagnostic is emitted. This setting is recommended for users who want to ensure the best possible experience for developers using their library in all supported languages, as it will prevent inadvertent use of one of those languages' reserved words in an identifier. Warning Setting this option might occasionally cause compilation to fail when performing a minor version upgrade to jsii ; in particular when support for a new language is introduced (as this may introduce additional reserved words, too). This situation will be improved in the future, as jsii will offer an option to only warn about reserved words of languages that are configured for the current project. Experimental Features Danger The features discussed in this section are experimental. Their behavior may change as bugs are addressed, and requirements are clarified through early adopters. Use at your own risk, and don't forget to report bugs you encounter while doing so! --strip-deprecated The --strip-deprecated option modifies the compilation flow such that all declarations (types, members) documented with the @deprecated tag will be erased from the visible API of the module: They will be removed from the TypeScript declarations ( .d.ts ) files They will be removed from the .jsii assembly file Inheritance chains of non- @deprecated types will have their @deprecated bases transitively replaced with non- @deprecated bases thereof (or if there are no such parents, the inheritance relationship will simply be erased) Errors will be reported for each remaining use of a @deprecated type in the API (this includes property types, method parameter types, and method return types) However, in order to ensure the underlying code continues to work as designed, the implementation of such declarations will remain in the JavaScript ( .js ) files produced by the compilation. This is, in fact, similar to marking all @deprecated members @internal . Additionally, a file name can be passed to the --strip-deprecated option to limit the above behavior to a specific set of allow-listed fully-qualified names. Each line in the file should contain a single fully-qualified name of a declaration that should be stripped. All @deprecated elements not present in the allow list will be retained. An example allowlist file might look like: testpkg.IDeprecated testpkg.DeprecatedOne testpkg.DeprecatedTwo#deprecatedProperty testpkg.DeprecatedTwo#deprecatedMethod --add-deprecated-warnings The --add-deprecated-warnings flag modifies the implementation of all declarations (types, members) documented with the @deprecated flag such that, when the deprecated declaration is used by a dependent, a warning is printed to the console at runtime. This is specifically useful to notify users of a jsii module that they are using deprecated elements and code updates are required. Additionally, the environment variable JSII_DEPRECATED can be set to error or quiet to either fail at runtime or silence these warnings, respectively. By default, this is set to warn . The JSII_DEPRECATED environment variable is respected only on modules compiled with the --add-deprecated-warnings flag.","title":"jsii"},{"location":"user-guides/lib-author/toolchain/jsii/#jsii","text":"The jsii tool wraps the standard TypeScript compiler, applies the TypeScript restrictions , producing additional diagnostic messages as necessary.","title":"jsii"},{"location":"user-guides/lib-author/toolchain/jsii/#options","text":"Info This section discusses the main options of jsii only. There may be additional options not mentioned on this page, which can learn about using jsii --help .","title":"Options"},{"location":"user-guides/lib-author/toolchain/jsii/#-watch","text":"The --watch option behaves similar to that of the standard TypeScript compiler. It will make jsii listen to file changes within the project, and recompile whenever a source file has changed (including producing diagnostic messages, and a new .jsii assembly file as needed). This option is useful when iterating on your code, as it provides a faster feedback loop than periodically manually re-compiling.","title":"--watch"},{"location":"user-guides/lib-author/toolchain/jsii/#-project-references","text":"When --project-references is specified, jsii will generate a tsconfig.json file that includes references to any other local jsii project present in the dependency closure of the current one. This option is recommended for any project that is part of a mono-repository, where multiple jsii packages are being maintained. It can result in improved build times, and a better IDE experience.","title":"--project-references"},{"location":"user-guides/lib-author/toolchain/jsii/#-fail-on-warnings","text":"The --fail-on-warnings option causes compilation top fail if any warning diagnostic is emitted. This setting is recommended for users who want to ensure the best possible experience for developers using their library in all supported languages, as it will prevent inadvertent use of one of those languages' reserved words in an identifier. Warning Setting this option might occasionally cause compilation to fail when performing a minor version upgrade to jsii ; in particular when support for a new language is introduced (as this may introduce additional reserved words, too). This situation will be improved in the future, as jsii will offer an option to only warn about reserved words of languages that are configured for the current project.","title":"--fail-on-warnings"},{"location":"user-guides/lib-author/toolchain/jsii/#experimental-features","text":"Danger The features discussed in this section are experimental. Their behavior may change as bugs are addressed, and requirements are clarified through early adopters. Use at your own risk, and don't forget to report bugs you encounter while doing so!","title":"Experimental Features"},{"location":"user-guides/lib-author/toolchain/jsii/#-strip-deprecated","text":"The --strip-deprecated option modifies the compilation flow such that all declarations (types, members) documented with the @deprecated tag will be erased from the visible API of the module: They will be removed from the TypeScript declarations ( .d.ts ) files They will be removed from the .jsii assembly file Inheritance chains of non- @deprecated types will have their @deprecated bases transitively replaced with non- @deprecated bases thereof (or if there are no such parents, the inheritance relationship will simply be erased) Errors will be reported for each remaining use of a @deprecated type in the API (this includes property types, method parameter types, and method return types) However, in order to ensure the underlying code continues to work as designed, the implementation of such declarations will remain in the JavaScript ( .js ) files produced by the compilation. This is, in fact, similar to marking all @deprecated members @internal . Additionally, a file name can be passed to the --strip-deprecated option to limit the above behavior to a specific set of allow-listed fully-qualified names. Each line in the file should contain a single fully-qualified name of a declaration that should be stripped. All @deprecated elements not present in the allow list will be retained. An example allowlist file might look like: testpkg.IDeprecated testpkg.DeprecatedOne testpkg.DeprecatedTwo#deprecatedProperty testpkg.DeprecatedTwo#deprecatedMethod","title":"--strip-deprecated"},{"location":"user-guides/lib-author/toolchain/jsii/#-add-deprecated-warnings","text":"The --add-deprecated-warnings flag modifies the implementation of all declarations (types, members) documented with the @deprecated flag such that, when the deprecated declaration is used by a dependent, a warning is printed to the console at runtime. This is specifically useful to notify users of a jsii module that they are using deprecated elements and code updates are required. Additionally, the environment variable JSII_DEPRECATED can be set to error or quiet to either fail at runtime or silence these warnings, respectively. By default, this is set to warn . The JSII_DEPRECATED environment variable is respected only on modules compiled with the --add-deprecated-warnings flag.","title":"--add-deprecated-warnings"},{"location":"user-guides/lib-user/","text":"Prerequisites Common Runtime Regardless of which language or platform your application is developed in, using jsii modules requires a compatible node runtime to be available in $PATH (see Runtime Architecture ). Current node runtime versions support status is as follows: The following node releases are part of our test matrix: Release Status End-of-Life ^14.6.0 Supported 2023-04-30 ^16.3.0 Supported 2024-04-30 ^18.0.0 Supported 2025-04-30 Status Definitions Supported : Long Term Support (LTS) releases (those with an even major version) are supported and bugs specific to those releases are addressed with the highest priority. Every jsii release is automatically tested against those releases. Best effort : Development releases (those with an odd major version) are supported on a best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors that we may not be able to fix. Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release. The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each).","title":"Prerequisites"},{"location":"user-guides/lib-user/#prerequisites","text":"","title":"Prerequisites"},{"location":"user-guides/lib-user/#common-runtime","text":"Regardless of which language or platform your application is developed in, using jsii modules requires a compatible node runtime to be available in $PATH (see Runtime Architecture ). Current node runtime versions support status is as follows: The following node releases are part of our test matrix: Release Status End-of-Life ^14.6.0 Supported 2023-04-30 ^16.3.0 Supported 2024-04-30 ^18.0.0 Supported 2025-04-30 Status Definitions Supported : Long Term Support (LTS) releases (those with an even major version) are supported and bugs specific to those releases are addressed with the highest priority. Every jsii release is automatically tested against those releases. Best effort : Development releases (those with an odd major version) are supported on a best-effort basis. Some of these releases may include breaking changes or bugs that may cause runtime errors that we may not be able to fix. Releases not in the matrix might work, but are not guaranteed to: they can be considered to fall under the Best Effort umbrella, unless they are end-of-life. Releases past end-of-life are unlikely to work, or may stop working with any future release. The node releases schedule provides up-to-date information on the current status of all active releases, and indicates the timelines for support (including planned End-of-Life dates for each).","title":" Common Runtime"},{"location":"user-guides/lib-user/language-specific/go/","text":"Go Go is not a common object-oriented language: the language currently only supports composition, not extension. On the other hand, the jsii type system includes classes and interfaces , which are typically associated with extension-based programming models. In rare circumstances, Go developers may find themselves in a situation where they must implement an abstract base class , extend some class in order to override a method or property, or implement a jsii interface . Implementing jsii interfaces Implementing jsii interfaces leverages the idiomatic go way to implement interfaces: define all the necessary methods on the implementing go struct, and the value can be used naturally. There is a single restriction: all such implementation methods must be defined using a pointer receiver , or a runtime error may occur: Assuming you are consuming a jsii module that defines the following: package jsiimodule import ( \"fmt\" ) type IGreeter interface { Greet ( greetee string ) } // ... func NewMajestyGreeter ( greeter IGreeter ) MajestyGreeter { // Omitted for brevity } // Does something with the IGreeter that was provided at construction time func ( m MajestyGreeter ) Announce ( who string ) { m . greeter . Greet ( fmt . Sprintf ( \"Your Royal Highness %s\" , who )) } You can implement this interface natively in go as: package main import ( \"fmt\" \"example/jsiimodule\" ) type greeter struct { _ byte // padding } // IMPORTANT - this function has a pointer receiver! func ( g * greeter ) Greet ( greetee string ) { fmt . Printf ( \"Hello, %s!\\n\" , greetee ) } func main () { g := & greeter {} // Simply pass the instance though, it \"just works\". mg := jsiimodule . NewMajestyGreeter ( g ) mg . Announce ( \"Elizabeth II\" ) } Extending and overriding classes Important Leveraging extension and override goes against the design principles of the go programming language. We advise you avoid using this mechanism unless you have determined that there is no way to achieve the desired result with composition. In particular, if the only element you need to override on a class is it's constructor , you should simply decorate this constructor instead of using the extension and overrides mechanism. For example you can declare an AWS CDK construct (that does not declare new properties or methods) in the following way: package cdkapp import ( \"github.com/aws/aws-cdk-go\" \"github.com/aws/aws-cdk-go/aws-s3\" ) // Optional: alias the type for clarity type CustomBucket s3 . Bucket // Imagine this builds an S3 bucket with \"special\" defaults. It does not // accept s3.BucketProps, instead those are hard-coded in the constructor // itself. It could also accept a different properties object, to allow for // user settings? func NewCustomBucket ( scope core . Construct , id string ) CustomBucket { return s3 . NewBucket ( scope , id , s3 . BucketProps { // ... customized properties }) } Classes that are open for extension (including abstract base classes ) have a special overriding constructor that can be used when building sub-classes. This override constructor is expected to be called from within the child class constructor that you are writing. This constructor is named using the following convention: New<ClassName>_Override , and receives the overriding struct instance as the first parameter. The go struct that extends the base jsii class must anonymously embed the jsii class ' go interface. All overridden method must be defined using a pointer receiver. Assuming the following abstract base class: package jsiimodule type AbstractBaseClass interface { // Those members have implementations provided, you *may* override them ConcreteMethod () bool ConcreteProperty () string SetConcreteProperty ( v string ) // Those members do not have implementations, you *must* implement them AbstractMethod () string AbstractReadonlyProperty () float64 } // NewAbstractBaseClass_Override initializes an overridden AbstractBaseClass // instance. The inst parameter receives the go struct that declares the // overrides, while the someString and someNumber are parameters to the abstract // base class' constructor. func NewAbstractBaseClass_Override ( inst AbstractBaseClass , someString string , someNumber float64 ) { // Omitted for brevity } You can implement that abstract base class in go in the following way: package main import ( \"fmt\" \"strings\" \"example/jsiimodule\" ) type childClass struct { // Anonymous embed of the \"base class\". jsiimodule . AbstractBaseClass // Our own storage stringValue string } // Provide your own constructor, which delegates to the base class' overriding // constructor. func NewChildClass ( stringValue string , someString string , someNumber float64 ) jsiimodule . AbstractBaseClass { c := & childClass { stringValue : stringValue } // This will take care of setting childClass.AbstractBaseClass! jsiimodule . NewAbstractBaseClass_Override ( c , someString , someNumber ) return c } // Then implement the necessary members func ( c * childClass ) AbstractMethod () string { fmt . Println ( \"childClass.AbstractMethod invoked!\" ) return c . stringValue } func ( c * childClass ) AbstractReadonlyProperty () float64 { fmt . Println ( \"childClass.ConcreteProperty read!\" ) return 1337 } // And overrides those we decided to replace func ( c * childClass ) SetConcreteProperty ( v string ) { // We'll just up-case before delegating to the \"super\" implementation. c . AbstractBaseClass . SetConcreteProperty ( strings . ToUpper ( v )) } Unchecked conversions using UnsafeCast Developers may occasionally need to down-cast a value in order to leverage some other interface it implements. This happens in cases where the runtime is unable to determine the complete dynamic type of a value returned by a function, which happens for example when the TypeScript version of that function returns any , unknown , or a union of several types (which cannot be represented in go). In such cases, traditional go type assertions may not always produce the expected result. Instead, the library that exposes these functions should also expose type-checking utilities (e.g: Stack.isStack(thing: any): boolean ) that developers can use to guard an unchecked conversion, which in Go is performed using UnsafeCast . The UnsafeCast function expects two arguments the original value, and a pointer to a variable of the desired interface type. Warning The UnsafeCast function may panic if: the provided original value was not obtained through a function exported from a jsii package. the provided pointer is not to a value typed as an interface exported from a jsii package. If the original value does, in fact, not implement the target interface type, undefined behavior will occur as a result of using functions of that interface. An example use of the UnsafeCast feature is when using AWS CDK escape hatches : package main import ( \"github.com/aws/aws-cdk-go/awscdk/v2\" \"github.com/aws/aws-cdk-go/awscdk/v2/awssns\" \"github.com/aws/jsii-runtime-go\" ) func main () { app := awscdk . NewApp ( nil ) stack := awscdk . NewStack ( app , jsii . String ( \"TestStack\" ), nil ) topic := awssns . NewTopic ( stack , jsii . String ( \"MyTopic\" ), nil ) // We know that topic.Node().DefaultChild() is a awssns.CfnTopic var cfn_topic awssns . CfnTopic // We perform the conversion into cfn_topic jsii . UnsafeCast ( topic . Node (). DefaultChild (), & cfn_topic ) // Then we use the conversion result cfn_topic . SetDisplayName ( jsii . String ( \"Overridden Display Name\" )) app . Synth ( nil ) }","title":"Go"},{"location":"user-guides/lib-user/language-specific/go/#go","text":"Go is not a common object-oriented language: the language currently only supports composition, not extension. On the other hand, the jsii type system includes classes and interfaces , which are typically associated with extension-based programming models. In rare circumstances, Go developers may find themselves in a situation where they must implement an abstract base class , extend some class in order to override a method or property, or implement a jsii interface .","title":"Go"},{"location":"user-guides/lib-user/language-specific/go/#implementing-jsii-interfaces","text":"Implementing jsii interfaces leverages the idiomatic go way to implement interfaces: define all the necessary methods on the implementing go struct, and the value can be used naturally. There is a single restriction: all such implementation methods must be defined using a pointer receiver , or a runtime error may occur: Assuming you are consuming a jsii module that defines the following: package jsiimodule import ( \"fmt\" ) type IGreeter interface { Greet ( greetee string ) } // ... func NewMajestyGreeter ( greeter IGreeter ) MajestyGreeter { // Omitted for brevity } // Does something with the IGreeter that was provided at construction time func ( m MajestyGreeter ) Announce ( who string ) { m . greeter . Greet ( fmt . Sprintf ( \"Your Royal Highness %s\" , who )) } You can implement this interface natively in go as: package main import ( \"fmt\" \"example/jsiimodule\" ) type greeter struct { _ byte // padding } // IMPORTANT - this function has a pointer receiver! func ( g * greeter ) Greet ( greetee string ) { fmt . Printf ( \"Hello, %s!\\n\" , greetee ) } func main () { g := & greeter {} // Simply pass the instance though, it \"just works\". mg := jsiimodule . NewMajestyGreeter ( g ) mg . Announce ( \"Elizabeth II\" ) }","title":"Implementing jsii interfaces"},{"location":"user-guides/lib-user/language-specific/go/#extending-and-overriding-classes","text":"Important Leveraging extension and override goes against the design principles of the go programming language. We advise you avoid using this mechanism unless you have determined that there is no way to achieve the desired result with composition. In particular, if the only element you need to override on a class is it's constructor , you should simply decorate this constructor instead of using the extension and overrides mechanism. For example you can declare an AWS CDK construct (that does not declare new properties or methods) in the following way: package cdkapp import ( \"github.com/aws/aws-cdk-go\" \"github.com/aws/aws-cdk-go/aws-s3\" ) // Optional: alias the type for clarity type CustomBucket s3 . Bucket // Imagine this builds an S3 bucket with \"special\" defaults. It does not // accept s3.BucketProps, instead those are hard-coded in the constructor // itself. It could also accept a different properties object, to allow for // user settings? func NewCustomBucket ( scope core . Construct , id string ) CustomBucket { return s3 . NewBucket ( scope , id , s3 . BucketProps { // ... customized properties }) } Classes that are open for extension (including abstract base classes ) have a special overriding constructor that can be used when building sub-classes. This override constructor is expected to be called from within the child class constructor that you are writing. This constructor is named using the following convention: New<ClassName>_Override , and receives the overriding struct instance as the first parameter. The go struct that extends the base jsii class must anonymously embed the jsii class ' go interface. All overridden method must be defined using a pointer receiver. Assuming the following abstract base class: package jsiimodule type AbstractBaseClass interface { // Those members have implementations provided, you *may* override them ConcreteMethod () bool ConcreteProperty () string SetConcreteProperty ( v string ) // Those members do not have implementations, you *must* implement them AbstractMethod () string AbstractReadonlyProperty () float64 } // NewAbstractBaseClass_Override initializes an overridden AbstractBaseClass // instance. The inst parameter receives the go struct that declares the // overrides, while the someString and someNumber are parameters to the abstract // base class' constructor. func NewAbstractBaseClass_Override ( inst AbstractBaseClass , someString string , someNumber float64 ) { // Omitted for brevity } You can implement that abstract base class in go in the following way: package main import ( \"fmt\" \"strings\" \"example/jsiimodule\" ) type childClass struct { // Anonymous embed of the \"base class\". jsiimodule . AbstractBaseClass // Our own storage stringValue string } // Provide your own constructor, which delegates to the base class' overriding // constructor. func NewChildClass ( stringValue string , someString string , someNumber float64 ) jsiimodule . AbstractBaseClass { c := & childClass { stringValue : stringValue } // This will take care of setting childClass.AbstractBaseClass! jsiimodule . NewAbstractBaseClass_Override ( c , someString , someNumber ) return c } // Then implement the necessary members func ( c * childClass ) AbstractMethod () string { fmt . Println ( \"childClass.AbstractMethod invoked!\" ) return c . stringValue } func ( c * childClass ) AbstractReadonlyProperty () float64 { fmt . Println ( \"childClass.ConcreteProperty read!\" ) return 1337 } // And overrides those we decided to replace func ( c * childClass ) SetConcreteProperty ( v string ) { // We'll just up-case before delegating to the \"super\" implementation. c . AbstractBaseClass . SetConcreteProperty ( strings . ToUpper ( v )) }","title":"Extending and overriding classes"},{"location":"user-guides/lib-user/language-specific/go/#unchecked-conversions-using-unsafecast","text":"Developers may occasionally need to down-cast a value in order to leverage some other interface it implements. This happens in cases where the runtime is unable to determine the complete dynamic type of a value returned by a function, which happens for example when the TypeScript version of that function returns any , unknown , or a union of several types (which cannot be represented in go). In such cases, traditional go type assertions may not always produce the expected result. Instead, the library that exposes these functions should also expose type-checking utilities (e.g: Stack.isStack(thing: any): boolean ) that developers can use to guard an unchecked conversion, which in Go is performed using UnsafeCast . The UnsafeCast function expects two arguments the original value, and a pointer to a variable of the desired interface type. Warning The UnsafeCast function may panic if: the provided original value was not obtained through a function exported from a jsii package. the provided pointer is not to a value typed as an interface exported from a jsii package. If the original value does, in fact, not implement the target interface type, undefined behavior will occur as a result of using functions of that interface. An example use of the UnsafeCast feature is when using AWS CDK escape hatches : package main import ( \"github.com/aws/aws-cdk-go/awscdk/v2\" \"github.com/aws/aws-cdk-go/awscdk/v2/awssns\" \"github.com/aws/jsii-runtime-go\" ) func main () { app := awscdk . NewApp ( nil ) stack := awscdk . NewStack ( app , jsii . String ( \"TestStack\" ), nil ) topic := awssns . NewTopic ( stack , jsii . String ( \"MyTopic\" ), nil ) // We know that topic.Node().DefaultChild() is a awssns.CfnTopic var cfn_topic awssns . CfnTopic // We perform the conversion into cfn_topic jsii . UnsafeCast ( topic . Node (). DefaultChild (), & cfn_topic ) // Then we use the conversion result cfn_topic . SetDisplayName ( jsii . String ( \"Overridden Display Name\" )) app . Synth ( nil ) }","title":"Unchecked conversions using UnsafeCast"},{"location":"user-guides/lib-user/language-specific/python/","text":"Python Due to the use of a custom metaclass as part of the jsii runtime for Python , certain Python idioms require unusual syntax when jsii modules are involved. Info Our intention is to make working with jsii modules from Python as idiomatic as possible. Removing the custom metaclass usage without breaking existing code is a challenging task, and the situation may consequently remain sub-optional for the near future at least. Implementing Interfaces Traditionally, Python developers expect to be able to either implicitly implement an interface by declaring all required members, or explicitly implement interfaces by simply adding the interface to their class' or interface's inheritance chain (and implementing all required members): Incorrect Use from jsii_dependency import IJsiiInterface class MyNewClass ( IJsiiInterface ): \"\"\" Traditional implementation of an interface in Python. This will not work with interfaces defined by jsii modules, as this will likely cause a metaclass conflict that the user cannot solve. \"\"\" # Member implementations... ... The jsii type system however does not support structural typing , and interfaces must always be explicitly implemented. In order to correctly declare implementation of an interface from a jsii module , the following syntax is used: import jsii from jsii_dependency import IJsiiInterface @jsii . implements ( IJsiiInterface ) class MyNewClass (): \"\"\" A jsii-supported implementation of the `IJsiiInterface` interface This will correctly register the explicit interface implementation on the type's metadata, and ensure instances get correctly serialized to and from the jsii kernel. \"\"\" # Member implementations... ... Property Overrides When extending or implementing types provided by jsii modules , properties must always be implemented using a dynamic accessor, ensuring the jsii runtime for Python is able to correctly process access to those by the jsii kernel . This leverages Python 's standard @property decorator: from jsii_greeter import Greeter class Shouter ( Greeter ): \"\"\" Shouter extends Greeter up-cases the greetee's name. The replacement is implemented using a dynamic @property implementation so it works properly with the jsii kernel. \"\"\" @property def greetee ( self ) -> str : return super () . greetee . upper () @greetee . setter def greetee ( self , value ): super () . greetee = value ...","title":"Python"},{"location":"user-guides/lib-user/language-specific/python/#python","text":"Due to the use of a custom metaclass as part of the jsii runtime for Python , certain Python idioms require unusual syntax when jsii modules are involved. Info Our intention is to make working with jsii modules from Python as idiomatic as possible. Removing the custom metaclass usage without breaking existing code is a challenging task, and the situation may consequently remain sub-optional for the near future at least.","title":" Python"},{"location":"user-guides/lib-user/language-specific/python/#implementing-interfaces","text":"Traditionally, Python developers expect to be able to either implicitly implement an interface by declaring all required members, or explicitly implement interfaces by simply adding the interface to their class' or interface's inheritance chain (and implementing all required members): Incorrect Use from jsii_dependency import IJsiiInterface class MyNewClass ( IJsiiInterface ): \"\"\" Traditional implementation of an interface in Python. This will not work with interfaces defined by jsii modules, as this will likely cause a metaclass conflict that the user cannot solve. \"\"\" # Member implementations... ... The jsii type system however does not support structural typing , and interfaces must always be explicitly implemented. In order to correctly declare implementation of an interface from a jsii module , the following syntax is used: import jsii from jsii_dependency import IJsiiInterface @jsii . implements ( IJsiiInterface ) class MyNewClass (): \"\"\" A jsii-supported implementation of the `IJsiiInterface` interface This will correctly register the explicit interface implementation on the type's metadata, and ensure instances get correctly serialized to and from the jsii kernel. \"\"\" # Member implementations... ...","title":"Implementing Interfaces"},{"location":"user-guides/lib-user/language-specific/python/#property-overrides","text":"When extending or implementing types provided by jsii modules , properties must always be implemented using a dynamic accessor, ensuring the jsii runtime for Python is able to correctly process access to those by the jsii kernel . This leverages Python 's standard @property decorator: from jsii_greeter import Greeter class Shouter ( Greeter ): \"\"\" Shouter extends Greeter up-cases the greetee's name. The replacement is implemented using a dynamic @property implementation so it works properly with the jsii kernel. \"\"\" @property def greetee ( self ) -> str : return super () . greetee . upper () @greetee . setter def greetee ( self , value ): super () . greetee = value ...","title":"Property Overrides"}]}